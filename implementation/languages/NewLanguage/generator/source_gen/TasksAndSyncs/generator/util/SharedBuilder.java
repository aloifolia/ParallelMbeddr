package TasksAndSyncs.generator.util;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import com.mbeddr.core.expressions.behavior.Type_Behavior;
import jetbrains.mps.generator.template.TemplateQueryContext;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;

public class SharedBuilder {
  /**
   * @type: a type that does not contain any typedefs
   */
  public static SNode getStructForSharedType(List<Pair<SNode, SNode>> typesAndStructs, SNode type) {
    // try to find an existing entry in the list 
    for (Pair<SNode, SNode> typeAndStruct : ListSequence.fromList(typesAndStructs)) {
      SNode currentType = typeAndStruct.first;
      if (Type_Behavior.call_isSubtypeOf_2124837493917340416(currentType, type) && Type_Behavior.call_isSubtypeOf_2124837493917340416(type, currentType)) {
        return typeAndStruct.second;
      }
    }
    return null;
  }



  /**
   * @returns: An equivalent struct type that does not contain any shared types but corresponding struct types; 
   * the latter are generated on the fly during the process (or reused if a mapping from a shared to a struct type 
   * is already existant.
   * 
   * @param sharedType A shared type that does not contain any typedefs.
   */
  public static SNode mapSharedToStructType(TemplateQueryContext genContext, List<Pair<SNode, SNode>> typesAndStructs, SNode sharedType) {
    final Wrappers._T<SNode> knownStruct = new Wrappers._T<SNode>(getStructForSharedType(typesAndStructs, sharedType));
    if (knownStruct.value != null) {
    } else {
      SNode sharedTypeCopy = SNodeOperations.copyNode(sharedType);
      SNode nestedSharedType = ListSequence.fromList(SNodeOperations.getDescendants(sharedTypeCopy, "TasksAndSyncs.structure.SharedType", false, new String[]{})).first();
      if ((nestedSharedType == null)) {
        knownStruct.value = SyncBuilder.buildSharedStruct(genContext, SLinkOperations.getTarget(sharedType, "baseType", true));
      } else {
        SNodeOperations.replaceWithAnother(nestedSharedType, mapSharedToStructType(genContext, typesAndStructs, nestedSharedType));
        knownStruct.value = SyncBuilder.buildSharedStruct(genContext, SLinkOperations.getTarget(sharedTypeCopy, "baseType", true));
      }
      ListSequence.fromList(typesAndStructs).addElement(new Pair(sharedType, knownStruct.value));
    }
    return new _FunctionTypes._return_P0_E0<SNode>() {
      public SNode invoke() {
        SNode node_4335879941183699229 = new _FunctionTypes._return_P0_E0<SNode>() {
          public SNode invoke() {
            SNode res = SConceptOperations.createNewNode("com.mbeddr.core.udt.structure.StructType", null);
            SLinkOperations.setTarget(res, "struct", knownStruct.value, false);
            return res;
          }
        }.invoke();
        return node_4335879941183699229;
      }
    }.invoke();
  }
}
