package TasksAndSyncs.generator.util;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SModel;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.IMapping;
import java.util.List;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.util.ArrayList;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.internal.collections.runtime.Sequence;
import TasksAndSyncs.behavior.SyncRessource_Behavior;

public class Optimizer {

  /*package*/ SModel model;


  public void init(SModel model) {
    this.model = model;
  }




  /**
   * Only consider direct function calls, disregard function passes via parameters (like lambdas)
   */
  public Map<SNode, Set<SNode>> createCallGraph() {
    Map<SNode, Set<SNode>> functionToCalledFunctions = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());

    for (SNode implementationModule : ListSequence.fromList(SModelOperations.getRoots(model, "com.mbeddr.core.modules.structure.ImplementationModule"))) {
      for (SNode function : ListSequence.fromList(SNodeOperations.getDescendants(implementationModule, "com.mbeddr.core.modules.structure.Function", false, new String[]{}))) {
        for (SNode functionCall : ListSequence.fromList(SNodeOperations.getDescendants(function, "com.mbeddr.core.modules.structure.FunctionCall", false, new String[]{})).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return (SNodeOperations.getAncestor(it, "com.mbeddr.core.modules.structure.Closure", false, false) == null) && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, "function", false), "com.mbeddr.core.modules.structure.Function");
          }
        })) {
          if (!(MapSequence.fromMap(functionToCalledFunctions).containsKey(function))) {
            MapSequence.fromMap(functionToCalledFunctions).put(function, SetSequence.fromSet(new HashSet<SNode>()));
          }
          SetSequence.fromSet(MapSequence.fromMap(functionToCalledFunctions).get(function)).addElement(SNodeOperations.cast(SLinkOperations.getTarget(functionCall, "function", false), "com.mbeddr.core.modules.structure.Function"));
        }
      }
    }

    return functionToCalledFunctions;
  }



  public Map<SNode, Set<SNode>> createDeepCallGraph() {
    Map<SNode, Set<SNode>> functionToCalledFunctions = createCallGraph();
    final Map<SNode, Set<SNode>> functionToDeeplyCalledFunctions = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());

    MapSequence.fromMap(functionToCalledFunctions).visitAll(new IVisitor<IMapping<SNode, Set<SNode>>>() {
      public void visit(IMapping<SNode, Set<SNode>> it) {
        MapSequence.fromMap(functionToDeeplyCalledFunctions).put(it.key(), SetSequence.fromSet(new HashSet<SNode>()));
        SetSequence.fromSet(MapSequence.fromMap(functionToDeeplyCalledFunctions).get(it.key())).addSequence(SetSequence.fromSet(it.value()));
      }
    });

    // should happen O(n) times 
    while (true) {
      boolean anyChangeHappened = false;
      // O(n) 
      for (IMapping<SNode, Set<SNode>> functionAndDeeplyCalledFunctions : MapSequence.fromMap(functionToDeeplyCalledFunctions)) {
        boolean changeForFunctionHappened = false;
        Set<SNode> nextCalledFunctions = SetSequence.fromSet(new HashSet<SNode>());
        // O(n) 
        for (SNode currentCalledFunction : SetSequence.fromSet(functionAndDeeplyCalledFunctions.value())) {
          // O(n) 
          for (SNode nextCalledFunction : SetSequence.fromSet(MapSequence.fromMap(functionToDeeplyCalledFunctions).get(currentCalledFunction))) {
            // O(log(n)) or O(1) 
            if (!(SetSequence.fromSet(functionAndDeeplyCalledFunctions.value()).contains(nextCalledFunction))) {
              anyChangeHappened = changeForFunctionHappened = true;
              SetSequence.fromSet(nextCalledFunctions).addElement(nextCalledFunction);
            }
          }
        }
        if (changeForFunctionHappened) {
          SetSequence.fromSet(nextCalledFunctions).addSequence(SetSequence.fromSet(functionAndDeeplyCalledFunctions.value()));
          MapSequence.fromMap(functionToDeeplyCalledFunctions).put(functionAndDeeplyCalledFunctions.key(), nextCalledFunctions);
        }
      }
      if (!(anyChangeHappened)) {
        break;
      }
    }

    return functionToDeeplyCalledFunctions;
  }



  public boolean callGraphContainsCycles(Map<SNode, Set<SNode>> functionToDeeplyCalledFunctions) {
    return MapSequence.fromMap(functionToDeeplyCalledFunctions).any(new IWhereFilter<IMapping<SNode, Set<SNode>>>() {
      public boolean accept(final IMapping<SNode, Set<SNode>> functionAndCallees) {
        return SetSequence.fromSet(functionAndCallees.value()).any(new IWhereFilter<SNode>() {
          public boolean accept(SNode calledFunction) {
            return functionAndCallees.key() == calledFunction;
          }
        });
      }
    });
  }



  public boolean isSharedType(SNode type) {
    return SNodeOperations.isInstanceOf(type, "TasksAndSyncs.structure.SharedType") || SNodeOperations.isInstanceOf(type, "com.mbeddr.core.pointers.structure.PointerType") && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(type, "com.mbeddr.core.pointers.structure.PointerType"), "baseType", true), "TasksAndSyncs.structure.SharedType");
  }



  public Map<SNode, Set<SNode>> createSimpleDataflowGraph(List<SNode> localVariables, List<SNode> arguments, List<SNode> variableRefs) {
    Map<SNode, Set<SNode>> nodeToTargets = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());
    List<SNode> allFunctionCalls = getFunctionCalls();

    for (SNode localVariable : ListSequence.fromList(localVariables).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, "type", true), "com.mbeddr.core.pointers.structure.PointerType");
      }
    })) {
      SNode initVariableReference = getVariableRef(SLinkOperations.getTarget(localVariable, "init", true));
      if ((initVariableReference != null)) {
        if (!(MapSequence.fromMap(nodeToTargets).containsKey(initVariableReference))) {
          MapSequence.fromMap(nodeToTargets).put(initVariableReference, SetSequence.fromSet(new HashSet<SNode>()));
        }
        SetSequence.fromSet(MapSequence.fromMap(nodeToTargets).get(initVariableReference)).addElement(localVariable);
      }
    }

    for (SNode argument : ListSequence.fromList(arguments).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, "type", true), "com.mbeddr.core.pointers.structure.PointerType");
      }
    })) {
      final SNode function = SNodeOperations.getAncestor(argument, "com.mbeddr.core.modules.structure.Function", false, false);
      List<SNode> calls = ListSequence.fromList(allFunctionCalls).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SLinkOperations.getTarget(it, "function", false) == function;
        }
      }).toListSequence();
      int argumentIndex = ListSequence.fromList(SLinkOperations.getTargets(function, "arguments", true)).indexOf(argument);
      for (SNode call : ListSequence.fromList(calls)) {
        SNode argumentValue = ListSequence.fromList(SLinkOperations.getTargets(call, "actuals", true)).getElement(argumentIndex);
        SNode initVariableReference = getVariableRef(argumentValue);
        if ((initVariableReference != null)) {
          if (!(MapSequence.fromMap(nodeToTargets).containsKey(initVariableReference))) {
            MapSequence.fromMap(nodeToTargets).put(initVariableReference, SetSequence.fromSet(new HashSet<SNode>()));
          }
          SetSequence.fromSet(MapSequence.fromMap(nodeToTargets).get(initVariableReference)).addElement(argument);
        }
      }
    }

    // TODO: remove 'where' 
    for (SNode variableRef : ListSequence.fromList(variableRefs)) {
      if (!(MapSequence.fromMap(nodeToTargets).containsKey(BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), variableRef, "virtual_getVariable_2486081302460156153", new Object[]{})))) {
        MapSequence.fromMap(nodeToTargets).put(BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), variableRef, "virtual_getVariable_2486081302460156153", new Object[]{}), SetSequence.fromSet(new HashSet<SNode>()));
      }
      SetSequence.fromSet(MapSequence.fromMap(nodeToTargets).get(BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), variableRef, "virtual_getVariable_2486081302460156153", new Object[]{}))).addElement(variableRef);
    }

    return nodeToTargets;
  }



  public Map<SNode, Set<SNode>> createAliases(List<SNode> allNodes, Map<SNode, Set<SNode>> dataFlowGraph) {
    Map<SNode, Set<SNode>> argumentsToInReferences = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());
    // save  
    Map<SNode, Set<SNode>> functionToContainedNodes = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());
    for (SNode node : ListSequence.fromList(allNodes)) {
      SNode function = SNodeOperations.getAncestor(node, "com.mbeddr.core.modules.structure.Function", false, false);
      if (!(MapSequence.fromMap(functionToContainedNodes).containsKey(function))) {
        MapSequence.fromMap(functionToContainedNodes).put(function, SetSequence.fromSet(new HashSet<SNode>()));
      }
      SetSequence.fromSet(MapSequence.fromMap(functionToContainedNodes).get(function)).addElement(node);
    }
    Map<SNode, Set<SNode>> functionToTabooNodes = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());
    for (SNode function : SetSequence.fromSet(MapSequence.fromMap(functionToContainedNodes).keySet())) {
      MapSequence.fromMap(functionToTabooNodes).put(function, SetSequence.fromSet(new HashSet<SNode>()));
    }

    final Map<SNode, Set<SNode>> aliases = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());
    for (IMapping<SNode, Set<SNode>> nodeToOtherNodes : MapSequence.fromMap(dataFlowGraph)) {
      if (!(MapSequence.fromMap(aliases).containsKey(nodeToOtherNodes.key()))) {
        MapSequence.fromMap(aliases).put(nodeToOtherNodes.key(), SetSequence.fromSet(new HashSet<SNode>()));
      }
      SetSequence.fromSet(MapSequence.fromMap(aliases).get(nodeToOtherNodes.key())).addSequence(SetSequence.fromSet(nodeToOtherNodes.value()));

      // for variable references (and pointers thereof) add mappings between these references and the referenced  
      // variables so that the latter never get lost 
      if (SNodeOperations.isInstanceOf(nodeToOtherNodes.key(), "com.mbeddr.core.statements.structure.IVariableReference")) {
        SNode variable = getVariableAndSyncRessource(SNodeOperations.cast(nodeToOtherNodes.key(), "com.mbeddr.core.expressions.structure.Expression")).first;
        SetSequence.fromSet(MapSequence.fromMap(aliases).get(nodeToOtherNodes.key())).addElement(variable);
        if (!(MapSequence.fromMap(aliases).containsKey(variable))) {
          MapSequence.fromMap(aliases).put(variable, SetSequence.fromSet(new HashSet<SNode>()));
        }
        SetSequence.fromSet(MapSequence.fromMap(aliases).get(variable)).addElement(nodeToOtherNodes.key());
        // TODO: remove 
        // for reference->argument keep the information that the reference is an inward reference 
        // so that later on aliases can be kept from flowing from one in-reference to another 
        if (SNodeOperations.isInstanceOf(variable, "com.mbeddr.core.modules.structure.Argument")) {
          if (!(MapSequence.fromMap(argumentsToInReferences).containsKey(SNodeOperations.cast(variable, "com.mbeddr.core.modules.structure.Argument")))) {
            MapSequence.fromMap(argumentsToInReferences).put(SNodeOperations.cast(variable, "com.mbeddr.core.modules.structure.Argument"), SetSequence.fromSet(new HashSet<SNode>()));
          }
          SetSequence.fromSet(MapSequence.fromMap(argumentsToInReferences).get(SNodeOperations.cast(variable, "com.mbeddr.core.modules.structure.Argument"))).addElement(SNodeOperations.cast(nodeToOtherNodes.key(), "com.mbeddr.core.statements.structure.IVariableReference"));
        }
      }
    }
    // make the connections bidirectional (or: remove the graph direction) 
    for (IMapping<SNode, Set<SNode>> nodeToOtherNodes : MapSequence.fromMap(dataFlowGraph)) {
      for (SNode otherNode : SetSequence.fromSet(nodeToOtherNodes.value())) {
        if (!(MapSequence.fromMap(aliases).containsKey(otherNode))) {
          MapSequence.fromMap(aliases).put(otherNode, SetSequence.fromSet(new HashSet<SNode>()));
        }
        SetSequence.fromSet(MapSequence.fromMap(aliases).get(otherNode)).addElement(nodeToOtherNodes.key());
      }
    }

    System.out.println("---------first aliases:");
    for (SNode alias : SetSequence.fromSet(MapSequence.fromMap(aliases).keySet())) {
      System.out.println("# " + alias + " : " + SNodeOperations.getConceptDeclaration(alias));
      SetSequence.fromSet(MapSequence.fromMap(aliases).get(alias)).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          System.out.println("--> " + it + " : " + SNodeOperations.getConceptDeclaration(it));
        }
      });
    }

    flowAliases(allNodes, aliases, functionToContainedNodes, functionToTabooNodes);

    System.out.println("---------second aliases:");
    for (SNode alias : SetSequence.fromSet(MapSequence.fromMap(aliases).keySet())) {
      System.out.println("# " + alias + " : " + SNodeOperations.getConceptDeclaration(alias));
      SetSequence.fromSet(MapSequence.fromMap(aliases).get(alias)).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          System.out.println("--> " + it + " : " + SNodeOperations.getConceptDeclaration(it));
        }
      });
    }

    // remove all references in order to extract the variables 
    List<SNode> nodesToRemove = SetSequence.fromSet(MapSequence.fromMap(aliases).keySet()).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "com.mbeddr.core.statements.structure.IVariableReference");
      }
    }).toListSequence();
    ListSequence.fromList(nodesToRemove).visitAll(new IVisitor<SNode>() {
      public void visit(final SNode node) {
        MapSequence.fromMap(aliases).removeKey(node);
        MapSequence.fromMap(aliases).visitAll(new IVisitor<IMapping<SNode, Set<SNode>>>() {
          public void visit(IMapping<SNode, Set<SNode>> it) {
            SetSequence.fromSet(it.value()).removeElement(node);
          }
        });
      }
    });

    return aliases;
  }



  public void flowAliases(List<SNode> allNodes, Map<SNode, Set<SNode>> aliases, Map<SNode, Set<SNode>> functionToContainedNodes, Map<SNode, Set<SNode>> functionToTabooNodes) {
    boolean mustBeSameFunction = true;
    while (true) {
      Pair<SNode, SNode> nextAlias;
      // first let nodes flow through their own functions 
      nextAlias = findNextAlias(mustBeSameFunction, allNodes, aliases, functionToContainedNodes, functionToTabooNodes);
      if (mustBeSameFunction) {
        mustBeSameFunction = nextAlias != null;
      } else if (nextAlias == null) {
        break;
      }
      if (nextAlias != null) {
        SetSequence.fromSet(MapSequence.fromMap(aliases).get(nextAlias.first)).addElement(nextAlias.second);
        SNode nodeFunction = SNodeOperations.getAncestor(nextAlias.first, "com.mbeddr.core.modules.structure.Function", false, false);
        flowNodeThroughFunction(aliases, functionToContainedNodes, nodeFunction, nextAlias.second);
        // The node may never flow through nodeFunction again, thus it becomes taboo for nodeFunction. 
        SetSequence.fromSet(MapSequence.fromMap(functionToTabooNodes).get(nodeFunction)).addElement(nextAlias.second);
      }
    }
  }



  public Pair<SNode, SNode> findNextAlias(boolean mustBeSameFunction, List<SNode> allNodes, final Map<SNode, Set<SNode>> aliases, Map<SNode, Set<SNode>> functionToContainedNodes, Map<SNode, Set<SNode>> functionToTabooNodes) {
    for (final SNode node : ListSequence.fromList(allNodes)) {
      for (SNode connectedNode : SetSequence.fromSet(MapSequence.fromMap(aliases).get(node))) {
        for (SNode nextConnectedNode : SetSequence.fromSet(MapSequence.fromMap(aliases).get(connectedNode)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return !(SetSequence.fromSet(MapSequence.fromMap(aliases).get(node)).contains(it));
          }
        })) {
          // avoid alias flows between nodes that are solely connected via a node of a different function 
          // e.g. fun(ref1), fun(ref2) with fun(arg){}: avoid flows ref1<->arg<->ref2 
          SNode nodeFunction = SNodeOperations.getAncestor(node, "com.mbeddr.core.modules.structure.Function", false, false);
          SNode connectedNodeFunction = SNodeOperations.getAncestor(connectedNode, "com.mbeddr.core.modules.structure.Function", false, false);
          SNode nextConnectedNodeFunction = SNodeOperations.getAncestor(nextConnectedNode, "com.mbeddr.core.modules.structure.Function", false, false);
          if (SNodeOperations.isInstanceOf(node, "com.mbeddr.core.modules.structure.Argument") && SPropertyOperations.getString(SNodeOperations.cast(node, "com.mbeddr.core.modules.structure.Argument"), "name").equals("value") && SNodeOperations.isInstanceOf(nextConnectedNode, "com.mbeddr.core.statements.structure.LocalVariableDeclaration") && SPropertyOperations.getString(SNodeOperations.cast(nextConnectedNode, "com.mbeddr.core.statements.structure.LocalVariableDeclaration"), "name").equals("y")) {
            System.out.println("------candidate: " + node + " : " + SNodeOperations.getConceptDeclaration(node) + " <- " + nextConnectedNode + " : " + SNodeOperations.getConceptDeclaration(nextConnectedNode));
            System.out.println("same func wanted? " + (mustBeSameFunction));
            System.out.println("different actually? " + (nodeFunction != nextConnectedNodeFunction));
            System.out.println("unwanted crossing? " + (nodeFunction == nextConnectedNodeFunction && nodeFunction != connectedNodeFunction));
            System.out.println("taboo? " + (SetSequence.fromSet(MapSequence.fromMap(functionToTabooNodes).get(nodeFunction)).contains(nextConnectedNode)));
          }
          if (mustBeSameFunction && nodeFunction != nextConnectedNodeFunction) {
            continue;
          }
          if (nodeFunction == nextConnectedNodeFunction && nodeFunction != connectedNodeFunction) {
            continue;
          }
          // If a node n has visited every possible other node m_i of a function f in the alias graph only via  
          // connections between the nodes m_i it is safe to assume that another entry of n into f must happen 
          // via a path outside the subgraph of f. Such behavior must be avoided. 
          if (SetSequence.fromSet(MapSequence.fromMap(functionToTabooNodes).get(nodeFunction)).contains(nextConnectedNode)) {
            continue;
          }
          return new Pair(node, nextConnectedNode);
        }
      }
    }
    return null;
  }



  public void flowNodeThroughFunction(final Map<SNode, Set<SNode>> aliases, Map<SNode, Set<SNode>> functionToContainedNodes, final SNode function, final SNode node) {
    boolean changedSomething = true;
    Set<SNode> functionNodes = MapSequence.fromMap(functionToContainedNodes).get(function);
    while (changedSomething) {
      changedSomething = false;
      for (SNode functionNode : SetSequence.fromSet(functionNodes).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return !(SetSequence.fromSet(MapSequence.fromMap(aliases).get(it)).contains(node));
        }
      })) {
        if ((SetSequence.fromSet(MapSequence.fromMap(aliases).get(functionNode)).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode nextNode) {
            return SNodeOperations.getAncestor(nextNode, "com.mbeddr.core.modules.structure.Function", false, false) == function && SetSequence.fromSet(MapSequence.fromMap(aliases).get(nextNode)).contains(node);
          }
        }) != null)) {
          SetSequence.fromSet(MapSequence.fromMap(aliases).get(functionNode)).addElement(node);
          changedSomething = true;
        }
      }
    }
  }



  public Map<SNode, Boolean> createSyncStates(final Map<SNode, Set<SNode>> dataFlowGraph, Map<SNode, Set<SNode>> aliases, List<SNode> syncRessources) {
    final Map<SNode, Boolean> nodeToSyncState = MapSequence.fromMap(new HashMap<SNode, Boolean>());
    SetSequence.fromSet(MapSequence.fromMap(dataFlowGraph).keySet()).visitAll(new IVisitor<SNode>() {
      public void visit(SNode from) {
        MapSequence.fromMap(nodeToSyncState).put(from, false);
        SetSequence.fromSet(MapSequence.fromMap(dataFlowGraph).get(from)).visitAll(new IVisitor<SNode>() {
          public void visit(SNode to) {
            MapSequence.fromMap(nodeToSyncState).put(to, false);
          }
        });
      }
    });
    if (1 < 0) {
      System.out.println("...create sync states for..." + syncRessources);
    }
    List<SNode> shit = new ArrayList<SNode>();
    // every direct reference to an (aliased) synced variable is marked as 'synced' 
    for (SNode syncRessource : ListSequence.fromList(syncRessources)) {
      final SNode sync = SNodeOperations.getAncestor(syncRessource, "TasksAndSyncs.structure.SyncStatement", false, false);
      final Set<SNode> syncedVariables = SetSequence.fromSet(new HashSet<SNode>());
      SetSequence.fromSet(syncedVariables).addElement(getVariableAndSyncRessource(SLinkOperations.getTarget(syncRessource, "expression", true)).first);
      if (MapSequence.fromMap(aliases).containsKey(SetSequence.fromSet(syncedVariables).first())) {
        SetSequence.fromSet(MapSequence.fromMap(aliases).get(SetSequence.fromSet(syncedVariables).first())).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            SetSequence.fromSet(syncedVariables).addElement(SNodeOperations.cast(it, "com.mbeddr.core.statements.structure.IVariableDeclaration"));
          }
        });
      }
      if (1 < 0) {
        System.out.println("...synced var decs...");
        System.out.println("=> res: " + syncRessource + " -> " + sync + ", hash: " + System.identityHashCode(sync));
        SetSequence.fromSet(syncedVariables).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            System.out.println("-> " + it + ", hash: " + System.identityHashCode(it));
          }
        });
      }
      for (final SNode syncedVariable : SetSequence.fromSet(syncedVariables)) {
        System.out.println("...for sycned var " + syncedVariable + ", hash: " + System.identityHashCode(syncedVariable));
        if (1 < 0) {
          System.out.println("body: " + SLinkOperations.getTarget(sync, "body", true) + ", stmts: " + SLinkOperations.getTargets(SLinkOperations.getTarget(sync, "body", true), "statements", true));
          for (SNode expr : ListSequence.fromList(SNodeOperations.getDescendants(SLinkOperations.getTarget(sync, "body", true), "com.mbeddr.core.expressions.structure.Expression", false, new String[]{}))) {
            System.out.println("==>>" + expr + ", hash: " + System.identityHashCode(expr));
          }
          for (SNode stmt : ListSequence.fromList(SNodeOperations.getDescendants(SLinkOperations.getTarget(sync, "body", true), "com.mbeddr.core.statements.structure.Statement", false, new String[]{}))) {
            System.out.println("==|>" + stmt + ", hash: " + System.identityHashCode(stmt));
          }
        }
        for (SNode syncedVariableRef : ListSequence.fromList(SNodeOperations.getDescendants(SLinkOperations.getTarget(sync, "body", true), "com.mbeddr.core.statements.structure.IVariableReference", false, new String[]{})).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            SNode possibleSurroundingTask = SNodeOperations.getAncestor(it, "TasksAndSyncs.structure.Task", false, false);
            if (1 < 0) {
              System.out.println("-->" + it + ", hash: " + System.identityHashCode(it) + ", var: " + BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), it, "virtual_getVariable_2486081302460156153", new Object[]{}) + ", contained: " + MapSequence.fromMap(nodeToSyncState).containsKey(it));
            }
            return BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), it, "virtual_getVariable_2486081302460156153", new Object[]{}) == syncedVariable && MapSequence.fromMap(nodeToSyncState).containsKey(it) && ((possibleSurroundingTask == null) || ListSequence.fromList(SNodeOperations.getAncestors(sync, null, false)).contains(possibleSurroundingTask));
          }
        })) {
          MapSequence.fromMap(nodeToSyncState).put(syncedVariableRef, true);
          if (1 < 0) {
            System.out.println("TRUE:..." + syncedVariableRef + ", hash: " + System.identityHashCode(syncedVariableRef) + ", parent: " + SNodeOperations.getConceptDeclaration(SNodeOperations.getParent(syncedVariableRef)));
            System.out.println("-> 1pparent:" + SNodeOperations.getConceptDeclaration(SNodeOperations.getParent(SNodeOperations.getParent(syncedVariableRef))));
            System.out.println("...zero after round");
            MapSequence.fromMap(nodeToSyncState).visitAll(new IVisitor<IMapping<SNode, Boolean>>() {
              public void visit(IMapping<SNode, Boolean> it) {
                System.out.println("# for " + it.key() + " : " + SNodeOperations.getConceptDeclaration(it.key()) + " -> " + it.value());
                System.out.println("-> 2parent:" + SNodeOperations.getConceptDeclaration(SNodeOperations.getParent(it.key())));
              }
            });
            MapSequence.fromMap(nodeToSyncState).put(syncedVariableRef, false);
            ListSequence.fromList(shit).addElement(syncedVariableRef);
          }
        }
      }
    }
    if (1 < 0) {
      System.out.println("...first round -> equal? " + (ListSequence.fromList(shit).getElement(0) == ListSequence.fromList(shit).getElement(1)));
      System.out.println("...obj0: " + System.identityHashCode(ListSequence.fromList(shit).getElement(0)));
      System.out.println("...obj1: " + System.identityHashCode(ListSequence.fromList(shit).getElement(1)));
    }
    MapSequence.fromMap(nodeToSyncState).visitAll(new IVisitor<IMapping<SNode, Boolean>>() {
      public void visit(IMapping<SNode, Boolean> it) {
        System.out.println("# for " + it.key() + " : " + SNodeOperations.getConceptDeclaration(it.key()) + " -> " + it.value());
      }
    });

    Map<SNode, Set<SNode>> inverseDataflowGraph = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());
    for (IMapping<SNode, Set<SNode>> nodeToOthers : MapSequence.fromMap(dataFlowGraph)) {
      for (SNode other : SetSequence.fromSet(nodeToOthers.value())) {
        if (!(MapSequence.fromMap(inverseDataflowGraph).containsKey(other))) {
          MapSequence.fromMap(inverseDataflowGraph).put(other, SetSequence.fromSet(new HashSet<SNode>()));
        }
        SetSequence.fromSet(MapSequence.fromMap(inverseDataflowGraph).get(other)).addElement(nodeToOthers.key());
      }
    }

    // the sync states are propagated across function boundaries (only for calls, not returns) 
    boolean changedSomething = true;
    while (changedSomething) {
      changedSomething = false;
      for (SNode node : SetSequence.fromSet(MapSequence.fromMap(inverseDataflowGraph).keySet())) {
        if ((boolean) MapSequence.fromMap(nodeToSyncState).get(node) == false) {
          if (SNodeOperations.isInstanceOf(node, "com.mbeddr.core.modules.structure.Argument")) {
            MapSequence.fromMap(nodeToSyncState).put(node, SetSequence.fromSet(MapSequence.fromMap(inverseDataflowGraph).get(node)).all(new IWhereFilter<SNode>() {
              public boolean accept(SNode it) {
                return MapSequence.fromMap(nodeToSyncState).get(it);
              }
            }));
          } else {
            // TODO: maybe unnecessary to distinguish 
            MapSequence.fromMap(nodeToSyncState).put(node, SetSequence.fromSet(MapSequence.fromMap(inverseDataflowGraph).get(node)).any(new IWhereFilter<SNode>() {
              public boolean accept(SNode it) {
                return MapSequence.fromMap(nodeToSyncState).get(it);
              }
            }));
          }
          changedSomething |= MapSequence.fromMap(nodeToSyncState).get(node);
        }
      }
    }

    return nodeToSyncState;
  }




  /**
   * Remove sync ressources whose referred variables are already synchronized in the current context.
   */
  public void removeRecursiveLocks(Map<SNode, Boolean> nodeToSyncState, List<SNode> syncRessources) {
    for (SNode syncRessource : ListSequence.fromList(syncRessources)) {
      System.out.println("superfluous?" + syncRessource);
      if (MapSequence.fromMap(nodeToSyncState).get(getVariableRef(SLinkOperations.getTarget(syncRessource, "expression", true)))) {
        System.out.println("superfluous!" + syncRessource);
        SNodeOperations.deleteNode(syncRessource);
      }
    }
  }




  /**
   * Remove sync ressources for variables that are only read (directly or via some alias).
   */
  public void removeReadonlyLocks(Map<SNode, Set<SNode>> aliases, List<SNode> syncRessources, List<SNode> variables, final List<SNode> sharedSets) {
    System.out.println("shared sets: " + sharedSets);
    for (SNode variable : ListSequence.fromList(variables)) {
      final List<SNode> aliasesAndSelf = new ArrayList<SNode>();
      ListSequence.fromList(aliasesAndSelf).addElement(variable);
      if (MapSequence.fromMap(aliases).containsKey(variable)) {
        SetSequence.fromSet(MapSequence.fromMap(aliases).get(variable)).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            ListSequence.fromList(aliasesAndSelf).addElement(SNodeOperations.cast(it, "com.mbeddr.core.statements.structure.IVariableDeclaration"));
          }
        });
      }
      // if no .set expression exists for any alias of the current variable v every synchronization  
      // for v is redundant 
      System.out.println("variable set? " + variable + " of: " + SNodeOperations.getConceptDeclaration(variable));
      if (ListSequence.fromList(aliasesAndSelf).all(new IWhereFilter<SNode>() {
        public boolean accept(final SNode alias) {
          return ListSequence.fromList(sharedSets).where(new IWhereFilter<SNode>() {
            public boolean accept(SNode sharedSet) {
              SNode referredVariable = getVariableAndSyncRessource(SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(sharedSet), "com.mbeddr.core.expressions.structure.GenericDotExpression"), "expression", true)).first;
              System.out.println("ref var == alias?: " + referredVariable + " | " + alias);
              return referredVariable == alias;
            }
          }).isEmpty();
        }
      })) {
        System.out.println("-> variable not set: " + variable + " of: " + SNodeOperations.getConceptDeclaration(variable));
        for (final SNode alias : ListSequence.fromList(aliasesAndSelf)) {
          System.out.println("-> alias: " + alias + " of: " + SNodeOperations.getConceptDeclaration(alias));
          for (SNode aliasSyncRessource : ListSequence.fromList(syncRessources).where(new IWhereFilter<SNode>() {
            public boolean accept(SNode it) {
              return getVariableAndSyncRessource(SLinkOperations.getTarget(it, "expression", true)).first == alias;
            }
          })) {
            System.out.println("# no shared set for: " + alias + " and: " + aliasSyncRessource);
            SNodeOperations.deleteNode(aliasSyncRessource);
          }
        }
      }
    }
  }



  /**
   * Remove sync ressources for variables that are only read (directly or via some alias).
   */
  public void narrowSyncs(Map<SNode, Set<SNode>> aliases, List<SNode> syncs) {
    for (SNode sync : ListSequence.fromList(syncs)) {
      // gather all variables whose shared ressources are synchronized by the current sync 
      final Set<SNode> syncRessourceAliases = SetSequence.fromSet(new HashSet<SNode>());
      for (SNode syncRessource : ListSequence.fromList(SLinkOperations.getTargets(sync, "ressources", true))) {
        SNode variable = getVariableAndSyncRessource(SLinkOperations.getTarget(syncRessource, "expression", true)).first;
        SetSequence.fromSet(syncRessourceAliases).addElement(variable);
        SetSequence.fromSet(MapSequence.fromMap(aliases).get(variable)).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            SetSequence.fromSet(syncRessourceAliases).addElement(SNodeOperations.cast(it, "com.mbeddr.core.statements.structure.IVariableDeclaration"));
          }
        });
      }

      // shift every possible first statement out of sync (named resources need not be regarded as they 
      // are already desugared at this point) 
      for (SNode firstStatement : ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(sync, "body", true), "statements", true))) {
        boolean shiftIsUnsafe = ListSequence.fromList(SNodeOperations.getDescendants(firstStatement, "com.mbeddr.core.statements.structure.IVariableReference", false, new String[]{})).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return isSharedType(SNodeOperations.cast(TypeChecker.getInstance().getTypeOf(it), "com.mbeddr.core.expressions.structure.Type"));
          }
        }).any(new IWhereFilter<SNode>() {
          public boolean accept(SNode reference) {
            return SetSequence.fromSet(syncRessourceAliases).contains(getVariableAndSyncRessource(SNodeOperations.cast(reference, "com.mbeddr.core.expressions.structure.Expression")).first);
          }
        });
        if (shiftIsUnsafe) {
          break;
        }
        SNodeOperations.insertPrevSiblingChild(sync, firstStatement);
      }

      // do the same for the last statements of sync 
      for (SNode lastStatement : ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(sync, "body", true), "statements", true)).reversedList()) {
        boolean shiftIsUnsafe = ListSequence.fromList(SNodeOperations.getDescendants(lastStatement, "com.mbeddr.core.statements.structure.IVariableReference", false, new String[]{})).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return isSharedType(SNodeOperations.cast(TypeChecker.getInstance().getTypeOf(it), "com.mbeddr.core.expressions.structure.Type"));
          }
        }).any(new IWhereFilter<SNode>() {
          public boolean accept(SNode reference) {
            return SetSequence.fromSet(syncRessourceAliases).contains(getVariableAndSyncRessource(SNodeOperations.cast(reference, "com.mbeddr.core.expressions.structure.Expression")).first);
          }
        });
        if (shiftIsUnsafe) {
          break;
        }
        SNodeOperations.insertNextSiblingChild(sync, lastStatement);
      }
    }
  }



  public List<SNode> getFunctionCalls() {
    List<SNode> functionCalls = new ArrayList<SNode>();
    for (SNode implementationModule : ListSequence.fromList(SModelOperations.getRoots(model, "com.mbeddr.core.modules.structure.ImplementationModule"))) {
      ListSequence.fromList(functionCalls).addSequence(ListSequence.fromList(SNodeOperations.getDescendants(implementationModule, "com.mbeddr.core.modules.structure.FunctionCall", false, new String[]{})));
    }
    return functionCalls;
  }



  public List<SNode> getSurroundingSyncs(SNode node) {
    final SNode surroundingTask = SNodeOperations.getAncestor(node, "TasksAndSyncs.structure.Task", false, false);
    if ((surroundingTask == null)) {
      return Sequence.fromIterable(SNodeOperations.ofConcept(SNodeOperations.getAncestors(node, null, false), "TasksAndSyncs.structure.SyncStatement")).toListSequence();
    }
    return Sequence.fromIterable(SNodeOperations.ofConcept(SNodeOperations.getAncestors(node, null, false), "TasksAndSyncs.structure.SyncStatement")).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return ListSequence.fromList(SNodeOperations.getAncestors(it, null, false)).contains(surroundingTask);
      }
    }).toListSequence();
  }



  public SNode getSyncForVariable(SNode variable, SNode referringNode) {
    List<SNode> surroundingSyncs = getSurroundingSyncs(referringNode);
    if (ListSequence.fromList(surroundingSyncs).isEmpty()) {
      return null;
    }
    for (SNode surroundingSync : ListSequence.fromList(surroundingSyncs)) {
      for (SNode surroundingSyncRessource : ListSequence.fromList(SLinkOperations.getTargets(surroundingSync, "ressources", true))) {
        SNode otherVariable = SyncRessource_Behavior.call_getVariable_1469333039370134366(surroundingSyncRessource);
        if (otherVariable != null && otherVariable == variable) {
          return surroundingSyncRessource;
        }
      }
    }
    return null;
  }



  public Pair<SNode, SNode> getVariableAndSyncRessource(SNode expr) {
    if (SNodeOperations.isInstanceOf(expr, "com.mbeddr.core.statements.structure.LocalVarRef") || SNodeOperations.isInstanceOf(expr, "com.mbeddr.core.modules.structure.ArgumentRef")) {
      SNode initVariable = BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), SNodeOperations.cast(expr, "com.mbeddr.core.statements.structure.IVariableReference"), "virtual_getVariable_2486081302460156153", new Object[]{});
      SNode initVariableSyncRessource = getSyncForVariable(initVariable, expr);
      return new Pair(initVariable, initVariableSyncRessource);
    }
    if (SNodeOperations.isInstanceOf(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr") && (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr"), "expression", true), "com.mbeddr.core.statements.structure.LocalVarRef") || SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr"), "expression", true), "com.mbeddr.core.modules.structure.ArgumentRef"))) {
      SNode initVariable = BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), SNodeOperations.cast(SLinkOperations.getTarget(SNodeOperations.cast(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr"), "expression", true), "com.mbeddr.core.statements.structure.IVariableReference"), "virtual_getVariable_2486081302460156153", new Object[]{});
      SNode initVariableSyncRessource = getSyncForVariable(initVariable, expr);
      return new Pair(initVariable, initVariableSyncRessource);
    }
    System.out.println("instead: " + expr);
    return null;
  }



  public SNode getVariableRef(SNode expr) {
    if (SNodeOperations.isInstanceOf(expr, "com.mbeddr.core.statements.structure.LocalVarRef") || SNodeOperations.isInstanceOf(expr, "com.mbeddr.core.modules.structure.ArgumentRef")) {
      return SNodeOperations.cast(expr, "com.mbeddr.core.statements.structure.IVariableReference");
    }
    if (SNodeOperations.isInstanceOf(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr") && (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr"), "expression", true), "com.mbeddr.core.statements.structure.LocalVarRef") || SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr"), "expression", true), "com.mbeddr.core.modules.structure.ArgumentRef"))) {
      return SNodeOperations.cast(SLinkOperations.getTarget(SNodeOperations.cast(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr"), "expression", true), "com.mbeddr.core.statements.structure.IVariableReference");
    }
    return null;
  }



  public void removeRecursiveSyncs(final Map<SNode, Map<SNode, Boolean>> nodeToReferencedNodes, Set<SNode> nodesWithUnknownStates) {
    SetSequence.fromSet(nodesWithUnknownStates).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        MapSequence.fromMap(nodeToReferencedNodes).removeKey(it);
      }
    });
    for (IMapping<SNode, Map<SNode, Boolean>> syncResourceAndRefedNodes : MapSequence.fromMap(nodeToReferencedNodes).where(new IWhereFilter<IMapping<SNode, Map<SNode, Boolean>>>() {
      public boolean accept(IMapping<SNode, Map<SNode, Boolean>> it) {
        return SNodeOperations.isInstanceOf(it.key(), "TasksAndSyncs.structure.SyncRessource");
      }
    })) {
      boolean isSynced = MapSequence.fromMap(syncResourceAndRefedNodes.value()).all(new IWhereFilter<IMapping<SNode, Boolean>>() {
        public boolean accept(IMapping<SNode, Boolean> it) {
          return it.value();
        }
      });
      if (isSynced) {
        SNodeOperations.deleteNode(syncResourceAndRefedNodes.key());
      }
    }
  }
}
