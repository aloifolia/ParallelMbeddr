package TasksAndSyncs.generator.util;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SModel;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.IMapping;
import java.util.List;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import java.util.ArrayList;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import jetbrains.mps.internal.collections.runtime.Sequence;
import TasksAndSyncs.behavior.SyncRessource_Behavior;

public class Optimizer {

  /*package*/ SModel model;


  public void init(SModel model) {
    this.model = model;
  }



  /**
   * Only consider direct function calls, disregard function passes via parameters (like lambdas)
   */
  public Map<SNode, Set<SNode>> createCallGraph() {
    Map<SNode, Set<SNode>> functionToCalledFunctions = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());

    for (SNode implementationModule : ListSequence.fromList(SModelOperations.getRoots(model, "com.mbeddr.core.modules.structure.ImplementationModule"))) {
      for (SNode function : ListSequence.fromList(SNodeOperations.getDescendants(implementationModule, "com.mbeddr.core.modules.structure.Function", false, new String[]{}))) {
        for (SNode functionCall : ListSequence.fromList(SNodeOperations.getDescendants(function, "com.mbeddr.core.modules.structure.FunctionCall", false, new String[]{})).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return (SNodeOperations.getAncestor(it, "com.mbeddr.core.modules.structure.Closure", false, false) == null) && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, "function", false), "com.mbeddr.core.modules.structure.Function");
          }
        })) {
          if (!(MapSequence.fromMap(functionToCalledFunctions).containsKey(function))) {
            MapSequence.fromMap(functionToCalledFunctions).put(function, SetSequence.fromSet(new HashSet<SNode>()));
          }
          SetSequence.fromSet(MapSequence.fromMap(functionToCalledFunctions).get(function)).addElement(SNodeOperations.cast(SLinkOperations.getTarget(functionCall, "function", false), "com.mbeddr.core.modules.structure.Function"));
        }
      }
    }

    return functionToCalledFunctions;
  }



  public Map<SNode, Set<SNode>> createDeepCallGraph() {
    Map<SNode, Set<SNode>> functionToCalledFunctions = createCallGraph();
    final Map<SNode, Set<SNode>> functionToDeeplyCalledFunctions = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());

    MapSequence.fromMap(functionToCalledFunctions).visitAll(new IVisitor<IMapping<SNode, Set<SNode>>>() {
      public void visit(IMapping<SNode, Set<SNode>> it) {
        MapSequence.fromMap(functionToDeeplyCalledFunctions).put(it.key(), SetSequence.fromSet(new HashSet<SNode>()));
        SetSequence.fromSet(MapSequence.fromMap(functionToDeeplyCalledFunctions).get(it.key())).addSequence(SetSequence.fromSet(it.value()));
      }
    });

    // should happen O(n) times 
    while (true) {
      boolean anyChangeHappened = false;
      // O(n) 
      for (IMapping<SNode, Set<SNode>> functionAndDeeplyCalledFunctions : MapSequence.fromMap(functionToDeeplyCalledFunctions)) {
        boolean changeForFunctionHappened = false;
        Set<SNode> nextCalledFunctions = SetSequence.fromSet(new HashSet<SNode>());
        // O(n) 
        for (SNode currentCalledFunction : SetSequence.fromSet(functionAndDeeplyCalledFunctions.value())) {
          // O(n) 
          for (SNode nextCalledFunction : SetSequence.fromSet(MapSequence.fromMap(functionToDeeplyCalledFunctions).get(currentCalledFunction))) {
            // O(log(n)) or O(1) 
            if (!(SetSequence.fromSet(functionAndDeeplyCalledFunctions.value()).contains(nextCalledFunction))) {
              anyChangeHappened = changeForFunctionHappened = true;
              SetSequence.fromSet(nextCalledFunctions).addElement(nextCalledFunction);
            }
          }
        }
        if (changeForFunctionHappened) {
          SetSequence.fromSet(nextCalledFunctions).addSequence(SetSequence.fromSet(functionAndDeeplyCalledFunctions.value()));
          MapSequence.fromMap(functionToDeeplyCalledFunctions).put(functionAndDeeplyCalledFunctions.key(), nextCalledFunctions);
        }
      }
      if (!(anyChangeHappened)) {
        break;
      }
    }

    return functionToDeeplyCalledFunctions;
  }



  public boolean callGraphContainsCycles(Map<SNode, Set<SNode>> functionToDeeplyCalledFunctions) {
    return MapSequence.fromMap(functionToDeeplyCalledFunctions).any(new IWhereFilter<IMapping<SNode, Set<SNode>>>() {
      public boolean accept(final IMapping<SNode, Set<SNode>> functionAndCallees) {
        return SetSequence.fromSet(functionAndCallees.value()).any(new IWhereFilter<SNode>() {
          public boolean accept(SNode calledFunction) {
            return functionAndCallees.key() == calledFunction;
          }
        });
      }
    });
  }



  public boolean isSharedType(SNode type) {
    return SNodeOperations.isInstanceOf(type, "TasksAndSyncs.structure.SharedType") || SNodeOperations.isInstanceOf(type, "com.mbeddr.core.pointers.structure.PointerType") && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(type, "com.mbeddr.core.pointers.structure.PointerType"), "baseType", true), "TasksAndSyncs.structure.SharedType");
  }



  public Map<SNode, Set<SNode>> createSimpleDataflowGraph(List<SNode> localVariables, List<SNode> arguments, List<SNode> variableRefs) {
    Map<SNode, Set<SNode>> nodeToTargets = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());
    List<SNode> allFunctionCalls = getFunctionCalls();

    for (SNode localVariable : ListSequence.fromList(localVariables).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, "type", true), "com.mbeddr.core.pointers.structure.PointerType");
      }
    })) {
      SNode initVariableReference = getVariableRef(SLinkOperations.getTarget(localVariable, "init", true));
      if ((initVariableReference != null)) {
        if (!(MapSequence.fromMap(nodeToTargets).containsKey(initVariableReference))) {
          MapSequence.fromMap(nodeToTargets).put(initVariableReference, SetSequence.fromSet(new HashSet<SNode>()));
        }
        SetSequence.fromSet(MapSequence.fromMap(nodeToTargets).get(initVariableReference)).addElement(localVariable);
      }
    }

    for (SNode argument : ListSequence.fromList(arguments).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, "type", true), "com.mbeddr.core.pointers.structure.PointerType");
      }
    })) {
      final SNode function = SNodeOperations.getAncestor(argument, "com.mbeddr.core.modules.structure.Function", false, false);
      List<SNode> calls = ListSequence.fromList(allFunctionCalls).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SLinkOperations.getTarget(it, "function", false) == function;
        }
      }).toListSequence();
      int argumentIndex = ListSequence.fromList(SLinkOperations.getTargets(function, "arguments", true)).indexOf(argument);
      for (SNode call : ListSequence.fromList(calls)) {
        SNode argumentValue = ListSequence.fromList(SLinkOperations.getTargets(call, "actuals", true)).getElement(argumentIndex);
        SNode initVariableReference = getVariableRef(argumentValue);
        if ((initVariableReference != null)) {
          if (!(MapSequence.fromMap(nodeToTargets).containsKey(initVariableReference))) {
            MapSequence.fromMap(nodeToTargets).put(initVariableReference, SetSequence.fromSet(new HashSet<SNode>()));
          }
          SetSequence.fromSet(MapSequence.fromMap(nodeToTargets).get(initVariableReference)).addElement(argument);
        }
      }
    }

    for (SNode variableRef : ListSequence.fromList(variableRefs)) {
      if (!(MapSequence.fromMap(nodeToTargets).containsKey(BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), variableRef, "virtual_getVariable_2486081302460156153", new Object[]{})))) {
        MapSequence.fromMap(nodeToTargets).put(BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), variableRef, "virtual_getVariable_2486081302460156153", new Object[]{}), SetSequence.fromSet(new HashSet<SNode>()));
      }
      SetSequence.fromSet(MapSequence.fromMap(nodeToTargets).get(BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), variableRef, "virtual_getVariable_2486081302460156153", new Object[]{}))).addElement(variableRef);
    }

    return nodeToTargets;
  }



  public Map<SNode, Set<SNode>> createAliases(List<SNode> allNodes, Map<SNode, Set<SNode>> dataFlowGraph) {
    Map<SNode, Set<SNode>> functionToContainedNodes = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());
    for (SNode node : ListSequence.fromList(allNodes)) {
      SNode function = SNodeOperations.getAncestor(node, "com.mbeddr.core.modules.structure.Function", false, false);
      if (!(MapSequence.fromMap(functionToContainedNodes).containsKey(function))) {
        MapSequence.fromMap(functionToContainedNodes).put(function, SetSequence.fromSet(new HashSet<SNode>()));
      }
      SetSequence.fromSet(MapSequence.fromMap(functionToContainedNodes).get(function)).addElement(node);
    }
    Map<SNode, Set<SNode>> functionToTabooNodes = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());
    for (SNode function : SetSequence.fromSet(MapSequence.fromMap(functionToContainedNodes).keySet())) {
      MapSequence.fromMap(functionToTabooNodes).put(function, SetSequence.fromSet(new HashSet<SNode>()));
    }

    final Map<SNode, Set<SNode>> aliases = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());
    for (IMapping<SNode, Set<SNode>> nodeToOtherNodes : MapSequence.fromMap(dataFlowGraph)) {
      if (!(MapSequence.fromMap(aliases).containsKey(nodeToOtherNodes.key()))) {
        MapSequence.fromMap(aliases).put(nodeToOtherNodes.key(), SetSequence.fromSet(new HashSet<SNode>()));
      }
      SetSequence.fromSet(MapSequence.fromMap(aliases).get(nodeToOtherNodes.key())).addSequence(SetSequence.fromSet(nodeToOtherNodes.value()));

      // for variable references (and pointers thereof) add mappings between these references and the referenced  
      // variables so that the latter never get lost 
      if (SNodeOperations.isInstanceOf(nodeToOtherNodes.key(), "com.mbeddr.core.statements.structure.IVariableReference")) {
        SNode variable = getVariable(SNodeOperations.cast(nodeToOtherNodes.key(), "com.mbeddr.core.expressions.structure.Expression"));
        SetSequence.fromSet(MapSequence.fromMap(aliases).get(nodeToOtherNodes.key())).addElement(variable);
        if (!(MapSequence.fromMap(aliases).containsKey(variable))) {
          MapSequence.fromMap(aliases).put(variable, SetSequence.fromSet(new HashSet<SNode>()));
        }
        SetSequence.fromSet(MapSequence.fromMap(aliases).get(variable)).addElement(nodeToOtherNodes.key());
      }
    }
    // make the connections bidirectional (or: remove the graph direction) 
    for (IMapping<SNode, Set<SNode>> nodeToOtherNodes : MapSequence.fromMap(dataFlowGraph)) {
      for (SNode otherNode : SetSequence.fromSet(nodeToOtherNodes.value())) {
        if (!(MapSequence.fromMap(aliases).containsKey(otherNode))) {
          MapSequence.fromMap(aliases).put(otherNode, SetSequence.fromSet(new HashSet<SNode>()));
        }
        SetSequence.fromSet(MapSequence.fromMap(aliases).get(otherNode)).addElement(nodeToOtherNodes.key());
      }
    }

    flowAliases(allNodes, aliases, functionToContainedNodes, functionToTabooNodes);

    // remove all references in order to extract the variables 
    List<SNode> nodesToRemove = SetSequence.fromSet(MapSequence.fromMap(aliases).keySet()).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(it, "com.mbeddr.core.statements.structure.IVariableReference");
      }
    }).toListSequence();
    ListSequence.fromList(nodesToRemove).visitAll(new IVisitor<SNode>() {
      public void visit(final SNode node) {
        MapSequence.fromMap(aliases).removeKey(node);
        MapSequence.fromMap(aliases).visitAll(new IVisitor<IMapping<SNode, Set<SNode>>>() {
          public void visit(IMapping<SNode, Set<SNode>> it) {
            SetSequence.fromSet(it.value()).removeElement(node);
          }
        });
      }
    });

    return aliases;
  }



  public void flowAliases(List<SNode> allNodes, Map<SNode, Set<SNode>> aliases, Map<SNode, Set<SNode>> functionToContainedNodes, Map<SNode, Set<SNode>> functionToTabooNodes) {
    boolean mustBeSameFunction = true;
    while (true) {
      Pair<SNode, SNode> nextAlias;
      // first let nodes flow through their own functions 
      nextAlias = findNextAlias(mustBeSameFunction, allNodes, aliases, functionToContainedNodes, functionToTabooNodes);
      if (mustBeSameFunction) {
        mustBeSameFunction = nextAlias != null;
      } else if (nextAlias == null) {
        break;
      }
      if (nextAlias != null) {
        SetSequence.fromSet(MapSequence.fromMap(aliases).get(nextAlias.first)).addElement(nextAlias.second);
        SNode nodeFunction = SNodeOperations.getAncestor(nextAlias.first, "com.mbeddr.core.modules.structure.Function", false, false);
        flowNodeThroughFunction(aliases, functionToContainedNodes, nodeFunction, nextAlias.second);
        // The node may never flow through nodeFunction again, thus it becomes taboo for nodeFunction. 
        SetSequence.fromSet(MapSequence.fromMap(functionToTabooNodes).get(nodeFunction)).addElement(nextAlias.second);
      }
    }
  }



  public Pair<SNode, SNode> findNextAlias(boolean mustBeSameFunction, List<SNode> allNodes, final Map<SNode, Set<SNode>> aliases, Map<SNode, Set<SNode>> functionToContainedNodes, Map<SNode, Set<SNode>> functionToTabooNodes) {
    for (final SNode node : ListSequence.fromList(allNodes)) {
      for (SNode connectedNode : SetSequence.fromSet(MapSequence.fromMap(aliases).get(node))) {
        for (SNode nextConnectedNode : SetSequence.fromSet(MapSequence.fromMap(aliases).get(connectedNode)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return !(SetSequence.fromSet(MapSequence.fromMap(aliases).get(node)).contains(it));
          }
        })) {
          // avoid alias flows between nodes that are solely connected via a node of a different function 
          // e.g. fun(ref1), fun(ref2) with fun(arg){}: avoid flows ref1<->arg<->ref2 
          SNode nodeFunction = SNodeOperations.getAncestor(node, "com.mbeddr.core.modules.structure.Function", false, false);
          SNode connectedNodeFunction = SNodeOperations.getAncestor(connectedNode, "com.mbeddr.core.modules.structure.Function", false, false);
          SNode nextConnectedNodeFunction = SNodeOperations.getAncestor(nextConnectedNode, "com.mbeddr.core.modules.structure.Function", false, false);
          if (mustBeSameFunction && nodeFunction != nextConnectedNodeFunction) {
            continue;
          }
          if (nodeFunction == nextConnectedNodeFunction && nodeFunction != connectedNodeFunction) {
            continue;
          }
          // If a node n has visited every possible other node m_i of a function f in the alias graph only via  
          // connections between the nodes m_i it is safe to assume that another entry of n into f must happen 
          // via a path outside the subgraph of f. Such behavior must be avoided. 
          if (SetSequence.fromSet(MapSequence.fromMap(functionToTabooNodes).get(nodeFunction)).contains(nextConnectedNode)) {
            continue;
          }
          return new Pair(node, nextConnectedNode);
        }
      }
    }
    return null;
  }



  public void flowNodeThroughFunction(final Map<SNode, Set<SNode>> aliases, Map<SNode, Set<SNode>> functionToContainedNodes, final SNode function, final SNode node) {
    boolean changedSomething = true;
    Set<SNode> functionNodes = MapSequence.fromMap(functionToContainedNodes).get(function);
    while (changedSomething) {
      changedSomething = false;
      for (SNode functionNode : SetSequence.fromSet(functionNodes).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return !(SetSequence.fromSet(MapSequence.fromMap(aliases).get(it)).contains(node));
        }
      })) {
        if ((SetSequence.fromSet(MapSequence.fromMap(aliases).get(functionNode)).findFirst(new IWhereFilter<SNode>() {
          public boolean accept(SNode nextNode) {
            return SNodeOperations.getAncestor(nextNode, "com.mbeddr.core.modules.structure.Function", false, false) == function && SetSequence.fromSet(MapSequence.fromMap(aliases).get(nextNode)).contains(node);
          }
        }) != null)) {
          SetSequence.fromSet(MapSequence.fromMap(aliases).get(functionNode)).addElement(node);
          changedSomething = true;
        }
      }
    }
  }



  public Map<SNode, Boolean> createSyncStates(final Map<SNode, Set<SNode>> dataFlowGraph, Map<SNode, Set<SNode>> aliases, List<SNode> syncRessources) {
    final Map<SNode, Boolean> nodeToSyncState = MapSequence.fromMap(new HashMap<SNode, Boolean>());
    SetSequence.fromSet(MapSequence.fromMap(dataFlowGraph).keySet()).visitAll(new IVisitor<SNode>() {
      public void visit(SNode from) {
        MapSequence.fromMap(nodeToSyncState).put(from, false);
        SetSequence.fromSet(MapSequence.fromMap(dataFlowGraph).get(from)).visitAll(new IVisitor<SNode>() {
          public void visit(SNode to) {
            MapSequence.fromMap(nodeToSyncState).put(to, false);
          }
        });
      }
    });
    // every direct reference to an (aliased) synced variable is marked as 'synced' 
    for (SNode syncRessource : ListSequence.fromList(syncRessources)) {
      final SNode sync = SNodeOperations.getAncestor(syncRessource, "TasksAndSyncs.structure.SyncStatement", false, false);
      final Set<SNode> syncedVariables = SetSequence.fromSet(new HashSet<SNode>());
      SetSequence.fromSet(syncedVariables).addElement(getVariable(SLinkOperations.getTarget(syncRessource, "expression", true)));
      if (MapSequence.fromMap(aliases).containsKey(SetSequence.fromSet(syncedVariables).first())) {
        SetSequence.fromSet(MapSequence.fromMap(aliases).get(SetSequence.fromSet(syncedVariables).first())).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            SetSequence.fromSet(syncedVariables).addElement(SNodeOperations.cast(it, "com.mbeddr.core.statements.structure.IVariableDeclaration"));
          }
        });
      }
      for (final SNode syncedVariable : SetSequence.fromSet(syncedVariables)) {
        System.out.println("...for sycned var " + syncedVariable + ", hash: " + System.identityHashCode(syncedVariable));
        for (SNode syncedVariableRef : ListSequence.fromList(SNodeOperations.getDescendants(SLinkOperations.getTarget(sync, "body", true), "com.mbeddr.core.statements.structure.IVariableReference", false, new String[]{})).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            SNode possibleSurroundingTask = SNodeOperations.getAncestor(it, "TasksAndSyncs.structure.Task", false, false);
            return BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), it, "virtual_getVariable_2486081302460156153", new Object[]{}) == syncedVariable && MapSequence.fromMap(nodeToSyncState).containsKey(it) && ((possibleSurroundingTask == null) || ListSequence.fromList(SNodeOperations.getAncestors(sync, null, false)).contains(possibleSurroundingTask));
          }
        })) {
          MapSequence.fromMap(nodeToSyncState).put(syncedVariableRef, true);
        }
      }
    }

    Map<SNode, Set<SNode>> inverseDataflowGraph = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());
    for (IMapping<SNode, Set<SNode>> nodeToOthers : MapSequence.fromMap(dataFlowGraph)) {
      for (SNode other : SetSequence.fromSet(nodeToOthers.value())) {
        if (!(MapSequence.fromMap(inverseDataflowGraph).containsKey(other))) {
          MapSequence.fromMap(inverseDataflowGraph).put(other, SetSequence.fromSet(new HashSet<SNode>()));
        }
        SetSequence.fromSet(MapSequence.fromMap(inverseDataflowGraph).get(other)).addElement(nodeToOthers.key());
      }
    }

    // the sync states are propagated across function boundaries (only for calls, not returns) 
    boolean changedSomething = true;
    while (changedSomething) {
      changedSomething = false;
      for (SNode node : SetSequence.fromSet(MapSequence.fromMap(inverseDataflowGraph).keySet())) {
        if ((boolean) MapSequence.fromMap(nodeToSyncState).get(node) == false) {
          if (SNodeOperations.isInstanceOf(node, "com.mbeddr.core.modules.structure.Argument")) {
            MapSequence.fromMap(nodeToSyncState).put(node, SetSequence.fromSet(MapSequence.fromMap(inverseDataflowGraph).get(node)).all(new IWhereFilter<SNode>() {
              public boolean accept(SNode it) {
                return MapSequence.fromMap(nodeToSyncState).get(it);
              }
            }));
          } else {
            // TODO: maybe unnecessary to distinguish 
            MapSequence.fromMap(nodeToSyncState).put(node, SetSequence.fromSet(MapSequence.fromMap(inverseDataflowGraph).get(node)).any(new IWhereFilter<SNode>() {
              public boolean accept(SNode it) {
                return MapSequence.fromMap(nodeToSyncState).get(it);
              }
            }));
          }
          changedSomething |= MapSequence.fromMap(nodeToSyncState).get(node);
        }
      }
    }

    return nodeToSyncState;
  }




  /**
   * Remove sync ressources whose referred variables are already synchronized in the current context.
   */
  public void removeRecursiveLocks(Map<SNode, Boolean> nodeToSyncState, List<SNode> syncRessources) {
    for (SNode syncRessource : ListSequence.fromList(syncRessources)) {
      System.out.println("superfluous?" + syncRessource);
      if (MapSequence.fromMap(nodeToSyncState).get(getVariableRef(SLinkOperations.getTarget(syncRessource, "expression", true)))) {
        System.out.println("superfluous!" + syncRessource);
        SNodeOperations.deleteNode(syncRessource);
      }
    }
  }




  /**
   * Remove sync ressources for variables that are only read (directly or via some alias).
   */
  public void removeReadonlyLocks(Map<SNode, Set<SNode>> aliases, List<SNode> syncRessources, List<SNode> variables, final List<SNode> sharedSets) {
    for (SNode variable : ListSequence.fromList(variables)) {
      final List<SNode> aliasesAndSelf = new ArrayList<SNode>();
      ListSequence.fromList(aliasesAndSelf).addElement(variable);
      if (MapSequence.fromMap(aliases).containsKey(variable)) {
        SetSequence.fromSet(MapSequence.fromMap(aliases).get(variable)).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            ListSequence.fromList(aliasesAndSelf).addElement(SNodeOperations.cast(it, "com.mbeddr.core.statements.structure.IVariableDeclaration"));
          }
        });
      }
      // if no .set expression exists for any alias of the current variable v every synchronization  
      // for v is redundant 
      if (ListSequence.fromList(aliasesAndSelf).all(new IWhereFilter<SNode>() {
        public boolean accept(final SNode alias) {
          return ListSequence.fromList(sharedSets).where(new IWhereFilter<SNode>() {
            public boolean accept(SNode sharedSet) {
              return getVariable(SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(sharedSet), "com.mbeddr.core.expressions.structure.GenericDotExpression"), "expression", true)) == alias;
            }
          }).isEmpty();
        }
      })) {
        for (final SNode alias : ListSequence.fromList(aliasesAndSelf)) {
          for (SNode aliasSyncRessource : ListSequence.fromList(syncRessources).where(new IWhereFilter<SNode>() {
            public boolean accept(SNode it) {
              return getVariable(SLinkOperations.getTarget(it, "expression", true)) == alias;
            }
          })) {
            SNodeOperations.deleteNode(aliasSyncRessource);
          }
        }
      }
    }
  }



  /**
   * Remove sync ressources for variables that are only read (directly or via some alias).
   */
  public void narrowSyncs(Map<SNode, Set<SNode>> aliases, List<SNode> syncs) {
    for (SNode sync : ListSequence.fromList(syncs)) {
      // gather all variables whose shared ressources are synchronized by the current sync 
      final Set<SNode> syncRessourceAliases = SetSequence.fromSet(new HashSet<SNode>());
      for (SNode syncRessource : ListSequence.fromList(SLinkOperations.getTargets(sync, "ressources", true))) {
        SNode variable = getVariable(SLinkOperations.getTarget(syncRessource, "expression", true));
        SetSequence.fromSet(syncRessourceAliases).addElement(variable);
        SetSequence.fromSet(MapSequence.fromMap(aliases).get(variable)).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            SetSequence.fromSet(syncRessourceAliases).addElement(SNodeOperations.cast(it, "com.mbeddr.core.statements.structure.IVariableDeclaration"));
          }
        });
      }

      // in order to keep the scopes and 'shadows' of variables all shifted statements and the  
      // sync itself are wrapped inside another block 
      SNode surroundingBlock = null;
      List<SNode> firstStatements = new ArrayList<SNode>();
      List<SNode> lastStatements = new ArrayList<SNode>();

      // shift every possible first statement out of sync (named resources need not be regarded as they 
      // are already desugared at this point) 
      for (SNode firstStatement : ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(sync, "body", true), "statements", true))) {
        boolean shiftIsUnsafe = ListSequence.fromList(SNodeOperations.getDescendants(firstStatement, "com.mbeddr.core.statements.structure.IVariableReference", false, new String[]{})).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return isSharedType(SNodeOperations.cast(TypeChecker.getInstance().getTypeOf(it), "com.mbeddr.core.expressions.structure.Type"));
          }
        }).any(new IWhereFilter<SNode>() {
          public boolean accept(SNode reference) {
            return SetSequence.fromSet(syncRessourceAliases).contains(getVariable(SNodeOperations.cast(reference, "com.mbeddr.core.expressions.structure.Expression")));
          }
        });
        if (shiftIsUnsafe) {
          break;
        }
        ListSequence.fromList(firstStatements).addElement(firstStatement);
      }

      // do the same for the last statements of sync 
      for (SNode lastStatement : ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(sync, "body", true), "statements", true)).reversedList()) {
        boolean shiftIsUnsafe = ListSequence.fromList(SNodeOperations.getDescendants(lastStatement, "com.mbeddr.core.statements.structure.IVariableReference", false, new String[]{})).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return isSharedType(SNodeOperations.cast(TypeChecker.getInstance().getTypeOf(it), "com.mbeddr.core.expressions.structure.Type"));
          }
        }).any(new IWhereFilter<SNode>() {
          public boolean accept(SNode reference) {
            return SetSequence.fromSet(syncRessourceAliases).contains(getVariable(SNodeOperations.cast(reference, "com.mbeddr.core.expressions.structure.Expression")));
          }
        });
        if (shiftIsUnsafe) {
          break;
        }
        ListSequence.fromList(lastStatements).insertElement(0, lastStatement);
      }

      if (!(ListSequence.fromList(firstStatements).isEmpty()) || !(ListSequence.fromList(lastStatements).isEmpty())) {
        surroundingBlock = new _FunctionTypes._return_P0_E0<SNode>() {
          public SNode invoke() {
            SNode node_8220307879112385182 = new _FunctionTypes._return_P0_E0<SNode>() {
              public SNode invoke() {
                SNode res = SConceptOperations.createNewNode("com.mbeddr.core.statements.structure.StatementList", null);
                return res;
              }
            }.invoke();
            return node_8220307879112385182;
          }
        }.invoke();
        SNodeOperations.replaceWithAnother(sync, surroundingBlock);
        ListSequence.fromList(SLinkOperations.getTargets(surroundingBlock, "statements", true)).addSequence(ListSequence.fromList(firstStatements));
        ListSequence.fromList(SLinkOperations.getTargets(surroundingBlock, "statements", true)).addElement(sync);
        ListSequence.fromList(SLinkOperations.getTargets(surroundingBlock, "statements", true)).addSequence(ListSequence.fromList(lastStatements));
      }
    }
  }



  public List<SNode> getFunctionCalls() {
    List<SNode> functionCalls = new ArrayList<SNode>();
    for (SNode implementationModule : ListSequence.fromList(SModelOperations.getRoots(model, "com.mbeddr.core.modules.structure.ImplementationModule"))) {
      ListSequence.fromList(functionCalls).addSequence(ListSequence.fromList(SNodeOperations.getDescendants(implementationModule, "com.mbeddr.core.modules.structure.FunctionCall", false, new String[]{})));
    }
    return functionCalls;
  }



  public List<SNode> getSurroundingSyncs(SNode node) {
    final SNode surroundingTask = SNodeOperations.getAncestor(node, "TasksAndSyncs.structure.Task", false, false);
    if ((surroundingTask == null)) {
      return Sequence.fromIterable(SNodeOperations.ofConcept(SNodeOperations.getAncestors(node, null, false), "TasksAndSyncs.structure.SyncStatement")).toListSequence();
    }
    return Sequence.fromIterable(SNodeOperations.ofConcept(SNodeOperations.getAncestors(node, null, false), "TasksAndSyncs.structure.SyncStatement")).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return ListSequence.fromList(SNodeOperations.getAncestors(it, null, false)).contains(surroundingTask);
      }
    }).toListSequence();
  }



  public SNode getSyncForVariable(SNode variable, SNode referringNode) {
    List<SNode> surroundingSyncs = getSurroundingSyncs(referringNode);
    if (ListSequence.fromList(surroundingSyncs).isEmpty()) {
      return null;
    }
    for (SNode surroundingSync : ListSequence.fromList(surroundingSyncs)) {
      for (SNode surroundingSyncRessource : ListSequence.fromList(SLinkOperations.getTargets(surroundingSync, "ressources", true))) {
        SNode otherVariable = SyncRessource_Behavior.call_getVariable_1469333039370134366(surroundingSyncRessource);
        if (otherVariable != null && otherVariable == variable) {
          return surroundingSyncRessource;
        }
      }
    }
    return null;
  }



  public SNode getVariable(SNode expr) {
    if (SNodeOperations.isInstanceOf(expr, "com.mbeddr.core.statements.structure.LocalVarRef") || SNodeOperations.isInstanceOf(expr, "com.mbeddr.core.modules.structure.ArgumentRef")) {
      return BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), SNodeOperations.cast(expr, "com.mbeddr.core.statements.structure.IVariableReference"), "virtual_getVariable_2486081302460156153", new Object[]{});
    }
    if (SNodeOperations.isInstanceOf(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr") && (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr"), "expression", true), "com.mbeddr.core.statements.structure.LocalVarRef") || SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr"), "expression", true), "com.mbeddr.core.modules.structure.ArgumentRef"))) {
      return BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), SNodeOperations.cast(SLinkOperations.getTarget(SNodeOperations.cast(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr"), "expression", true), "com.mbeddr.core.statements.structure.IVariableReference"), "virtual_getVariable_2486081302460156153", new Object[]{});
    }
    return null;
  }



  public SNode getVariableRef(SNode expr) {
    if (SNodeOperations.isInstanceOf(expr, "com.mbeddr.core.statements.structure.LocalVarRef") || SNodeOperations.isInstanceOf(expr, "com.mbeddr.core.modules.structure.ArgumentRef")) {
      return SNodeOperations.cast(expr, "com.mbeddr.core.statements.structure.IVariableReference");
    }
    if (SNodeOperations.isInstanceOf(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr") && (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr"), "expression", true), "com.mbeddr.core.statements.structure.LocalVarRef") || SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr"), "expression", true), "com.mbeddr.core.modules.structure.ArgumentRef"))) {
      return SNodeOperations.cast(SLinkOperations.getTarget(SNodeOperations.cast(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr"), "expression", true), "com.mbeddr.core.statements.structure.IVariableReference");
    }
    return null;
  }



  public void removeRecursiveSyncs(final Map<SNode, Map<SNode, Boolean>> nodeToReferencedNodes, Set<SNode> nodesWithUnknownStates) {
    SetSequence.fromSet(nodesWithUnknownStates).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        MapSequence.fromMap(nodeToReferencedNodes).removeKey(it);
      }
    });
    for (IMapping<SNode, Map<SNode, Boolean>> syncResourceAndRefedNodes : MapSequence.fromMap(nodeToReferencedNodes).where(new IWhereFilter<IMapping<SNode, Map<SNode, Boolean>>>() {
      public boolean accept(IMapping<SNode, Map<SNode, Boolean>> it) {
        return SNodeOperations.isInstanceOf(it.key(), "TasksAndSyncs.structure.SyncRessource");
      }
    })) {
      boolean isSynced = MapSequence.fromMap(syncResourceAndRefedNodes.value()).all(new IWhereFilter<IMapping<SNode, Boolean>>() {
        public boolean accept(IMapping<SNode, Boolean> it) {
          return it.value();
        }
      });
      if (isSynced) {
        SNodeOperations.deleteNode(syncResourceAndRefedNodes.key());
      }
    }
  }
}
