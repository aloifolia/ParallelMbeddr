package TasksAndSyncs.generator.util;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.generator.template.TemplateQueryContext;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Set;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import java.util.List;
import jetbrains.mps.typesystem.inference.TypeChecker;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.Sequence;
import java.util.ArrayList;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.internal.collections.runtime.IMapping;
import jetbrains.mps.baseLanguage.closures.runtime._FunctionTypes;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SConceptOperations;
import TasksAndSyncs.behavior.SyncRessource_Behavior;

public class Optimizer {

  /*package*/ SModel model;
  /*package*/ TemplateQueryContext genContext;


  public void init(SModel model, TemplateQueryContext genContext) {
    this.model = model;
    this.genContext = genContext;
  }



  /**
   * Only consider direct function calls, disregard function passes via parameters (like lambdas)
   */
  public Map<SNode, Set<SNode>> createCallGraph() {
    Map<SNode, Set<SNode>> functionToCalledFunctions = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());

    for (SNode implementationModule : ListSequence.fromList(SModelOperations.getRoots(model, "com.mbeddr.core.modules.structure.ImplementationModule"))) {
      for (SNode function : ListSequence.fromList(SNodeOperations.getDescendants(implementationModule, "com.mbeddr.core.modules.structure.Function", false, new String[]{}))) {
        for (SNode functionCall : ListSequence.fromList(SNodeOperations.getDescendants(function, "com.mbeddr.core.modules.structure.FunctionCall", false, new String[]{})).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return (SNodeOperations.getAncestor(it, "com.mbeddr.core.modules.structure.Closure", false, false) == null) && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, "function", false), "com.mbeddr.core.modules.structure.Function");
          }
        })) {
          if (!(MapSequence.fromMap(functionToCalledFunctions).containsKey(function))) {
            MapSequence.fromMap(functionToCalledFunctions).put(function, SetSequence.fromSet(new HashSet<SNode>()));
          }
          SetSequence.fromSet(MapSequence.fromMap(functionToCalledFunctions).get(function)).addElement(SNodeOperations.cast(SLinkOperations.getTarget(functionCall, "function", false), "com.mbeddr.core.modules.structure.Function"));
        }
      }
    }

    return functionToCalledFunctions;
  }



  public boolean isSharedType(SNode type) {
    return SNodeOperations.isInstanceOf(type, "TasksAndSyncs.structure.SharedType") || SNodeOperations.isInstanceOf(type, "com.mbeddr.core.pointers.structure.PointerType") && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(type, "com.mbeddr.core.pointers.structure.PointerType"), "baseType", true), "TasksAndSyncs.structure.SharedType");
  }



  public Map<SNode, Set<SNode>> createSimpleDataflowGraph(List<SNode> localVariables, List<SNode> arguments, List<SNode> variableRefs) {
    Map<SNode, Set<SNode>> nodeToTargets = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());
    List<SNode> allFunctionCalls = getFunctionCalls();

    for (SNode localVariable : ListSequence.fromList(localVariables).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, "type", true), "com.mbeddr.core.pointers.structure.PointerType");
      }
    })) {
      SNode initVariableReference = getVariableRef(SLinkOperations.getTarget(localVariable, "init", true));
      if ((initVariableReference != null)) {
        if (!(MapSequence.fromMap(nodeToTargets).containsKey(initVariableReference))) {
          MapSequence.fromMap(nodeToTargets).put(initVariableReference, SetSequence.fromSet(new HashSet<SNode>()));
        }
        SetSequence.fromSet(MapSequence.fromMap(nodeToTargets).get(initVariableReference)).addElement(localVariable);
      }
    }

    for (SNode argument : ListSequence.fromList(arguments).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, "type", true), "com.mbeddr.core.pointers.structure.PointerType");
      }
    })) {
      final SNode function = SNodeOperations.getAncestor(argument, "com.mbeddr.core.modules.structure.Function", false, false);
      List<SNode> calls = ListSequence.fromList(allFunctionCalls).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SLinkOperations.getTarget(it, "function", false) == function;
        }
      }).toListSequence();
      int argumentIndex = ListSequence.fromList(SLinkOperations.getTargets(function, "arguments", true)).indexOf(argument);
      for (SNode call : ListSequence.fromList(calls)) {
        SNode argumentValue = ListSequence.fromList(SLinkOperations.getTargets(call, "actuals", true)).getElement(argumentIndex);
        SNode initVariableReference = getVariableRef(argumentValue);
        if ((initVariableReference != null)) {
          if (!(MapSequence.fromMap(nodeToTargets).containsKey(initVariableReference))) {
            MapSequence.fromMap(nodeToTargets).put(initVariableReference, SetSequence.fromSet(new HashSet<SNode>()));
          }
          SetSequence.fromSet(MapSequence.fromMap(nodeToTargets).get(initVariableReference)).addElement(argument);
        }
      }
    }

    for (SNode variableRef : ListSequence.fromList(variableRefs).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SNodeOperations.isInstanceOf(TypeChecker.getInstance().getTypeOf(it), "com.mbeddr.core.pointers.structure.PointerType") || SNodeOperations.isInstanceOf(getNearestContext(it), "com.mbeddr.core.modules.structure.Function") || getNearestContext(it) == getNearestContext(BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), it, "virtual_getVariable_2486081302460156153", new Object[]{}));
      }
    })) {
      if (!(MapSequence.fromMap(nodeToTargets).containsKey(BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), variableRef, "virtual_getVariable_2486081302460156153", new Object[]{})))) {
        MapSequence.fromMap(nodeToTargets).put(BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), variableRef, "virtual_getVariable_2486081302460156153", new Object[]{}), SetSequence.fromSet(new HashSet<SNode>()));
      }
      SetSequence.fromSet(MapSequence.fromMap(nodeToTargets).get(BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), variableRef, "virtual_getVariable_2486081302460156153", new Object[]{}))).addElement(variableRef);
    }

    return nodeToTargets;
  }



  public Map<SNode, Set<SNode>> removeRecursiveEdges(Map<SNode, Set<SNode>> dataflowGraph, SNode entryFunction, Map<SNode, Set<SNode>> callGraph) {
    final Map<SNode, Set<SNode>> nonRecursiveDataflowGraph = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());
    for (final SNode node : SetSequence.fromSet(MapSequence.fromMap(dataflowGraph).keySet())) {
      MapSequence.fromMap(nonRecursiveDataflowGraph).put(node, SetSequence.fromSet(new HashSet<SNode>()));
      SetSequence.fromSet(MapSequence.fromMap(dataflowGraph).get(node)).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          SetSequence.fromSet(MapSequence.fromMap(nonRecursiveDataflowGraph).get(node)).addElement(it);
        }
      });
    }

    Map<SNode, Set<SNode>> inverseCallAborescence = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());
    MapSequence.fromMap(inverseCallAborescence).put(entryFunction, SetSequence.fromSet(new HashSet<SNode>()));
    Set<SNode> functionsToVisit = SetSequence.fromSet(new HashSet<SNode>());
    SetSequence.fromSet(functionsToVisit).addElement(entryFunction);

    while (SetSequence.fromSet(functionsToVisit).isNotEmpty()) {
      final SNode function = SetSequence.fromSet(functionsToVisit).first();
      SetSequence.fromSet(functionsToVisit).removeElement(function);
      for (final SNode calledFunction : SetSequence.fromSet(MapSequence.fromMap(callGraph).get(function))) {
        if (pathToMainContainsFunction(inverseCallAborescence, calledFunction, entryFunction)) {
          // suppress sync flows via cyclic function calls => remove edges in dataflow graph 
          for (SNode node : SetSequence.fromSet(MapSequence.fromMap(dataflowGraph).keySet()).where(new IWhereFilter<SNode>() {
            public boolean accept(SNode it) {
              return SNodeOperations.getAncestor(it, "com.mbeddr.core.modules.structure.Function", false, false) == function;
            }
          })) {
            System.out.println("> for " + node + " : " + SNodeOperations.getConceptDeclaration(node));
            SetSequence.fromSet(MapSequence.fromMap(nonRecursiveDataflowGraph).get(node)).removeSequence(Sequence.fromIterable(SNodeOperations.ofConcept(MapSequence.fromMap(dataflowGraph).get(node), "com.mbeddr.core.modules.structure.Argument")).where(new IWhereFilter<SNode>() {
              public boolean accept(SNode it) {
                return SNodeOperations.getAncestor(it, "com.mbeddr.core.modules.structure.Function", false, false) == calledFunction;
              }
            }));
          }
        } else {
          SetSequence.fromSet(functionsToVisit).addElement(calledFunction);
          MapSequence.fromMap(inverseCallAborescence).put(calledFunction, SetSequence.fromSet(new HashSet<SNode>()));
          SetSequence.fromSet(MapSequence.fromMap(inverseCallAborescence).get(calledFunction)).addSequence(SetSequence.fromSet(MapSequence.fromMap(inverseCallAborescence).get(function)));
          SetSequence.fromSet(MapSequence.fromMap(inverseCallAborescence).get(calledFunction)).addElement(function);
        }
      }
    }

    return nonRecursiveDataflowGraph;
  }



  public boolean pathToMainContainsFunction(final Map<SNode, Set<SNode>> inverseCallAborescence, SNode currentFunction, final SNode functionToFind) {
    if (currentFunction == functionToFind) {
      return true;
    }
    if (SetSequence.fromSet(MapSequence.fromMap(inverseCallAborescence).get(currentFunction)).isEmpty()) {
      return false;
    }
    return SetSequence.fromSet(MapSequence.fromMap(inverseCallAborescence).get(currentFunction)).any(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return pathToMainContainsFunction(inverseCallAborescence, it, functionToFind);
      }
    });
  }



  public Map<SNode, Set<SNode>> createAliases(List<SNode> allNodes, Map<SNode, Set<SNode>> dataflowGraph, Map<SNode, Set<SNode>> inverseDataFlowGraph, boolean isStrict) {
    final Map<SNode, Set<SNode>> aliases = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());
    final Map<SNode, List<SNode>> nodeToPropagationContext = MapSequence.fromMap(new HashMap<SNode, List<SNode>>());

    ListSequence.fromList(allNodes).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        MapSequence.fromMap(aliases).put(it, SetSequence.fromSet(new HashSet<SNode>()));
        if (SNodeOperations.isInstanceOf(it, "com.mbeddr.core.modules.structure.Argument")) {
          MapSequence.fromMap(nodeToPropagationContext).put(it, new ArrayList<SNode>());
        } else if (SNodeOperations.isInstanceOf(it, "com.mbeddr.core.statements.structure.LocalVariableDeclaration")) {
          MapSequence.fromMap(nodeToPropagationContext).put(it, SNodeOperations.getNextSiblings(it, false));
        } else if (SNodeOperations.isInstanceOf(it, "com.mbeddr.core.statements.structure.IVariableReference")) {
          MapSequence.fromMap(nodeToPropagationContext).put(it, new ArrayList<SNode>());
        }
      }
    });

    for (final SNode variable : Sequence.fromIterable(SNodeOperations.ofConcept(allNodes, "com.mbeddr.core.statements.structure.IVariableDeclaration"))) {
      SetSequence.fromSet(MapSequence.fromMap(dataflowGraph).get(variable)).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          SetSequence.fromSet(MapSequence.fromMap(aliases).get(it)).addElement(variable);
        }
      });
      SetSequence.fromSet(MapSequence.fromMap(aliases).get(variable)).addElement(variable);
    }

    boolean foundSomething = true;
    while (foundSomething) {
      foundSomething = false;
      for (final SNode node : SetSequence.fromSet(MapSequence.fromMap(inverseDataFlowGraph).keySet())) {
        if (!(MapSequence.fromMap(inverseDataFlowGraph).containsKey(node)) || SetSequence.fromSet(MapSequence.fromMap(inverseDataFlowGraph).get(node)).isEmpty()) {
          continue;
        }

        final Set<SNode> firstInNodeAliases = MapSequence.fromMap(aliases).get(SetSequence.fromSet(MapSequence.fromMap(inverseDataFlowGraph).get(node)).first());
        if (isStrict && !(SetSequence.fromSet(MapSequence.fromMap(inverseDataFlowGraph).get(node)).all(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            Set<SNode> otherInNodeAliases = MapSequence.fromMap(aliases).get(it);
            return SetSequence.fromSet(firstInNodeAliases).containsSequence(SetSequence.fromSet(otherInNodeAliases)) && SetSequence.fromSet(otherInNodeAliases).containsSequence(SetSequence.fromSet(firstInNodeAliases));
          }
        }))) {
          continue;
        }

        // gather all aliases from in nodes 
        int originalAliasCount = SetSequence.fromSet(MapSequence.fromMap(aliases).get(node)).count();
        SetSequence.fromSet(MapSequence.fromMap(inverseDataFlowGraph).get(node)).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            SetSequence.fromSet(MapSequence.fromMap(aliases).get(node)).addSequence(SetSequence.fromSet(MapSequence.fromMap(aliases).get(it)));
          }
        });
        if (SetSequence.fromSet(MapSequence.fromMap(aliases).get(node)).count() == originalAliasCount) {
          continue;
        }

        foundSomething = true;
        for (SNode contextStatement : ListSequence.fromList(MapSequence.fromMap(nodeToPropagationContext).get(node))) {
          for (SNode ref : ListSequence.fromList(SNodeOperations.getDescendants(contextStatement, "com.mbeddr.core.statements.structure.IVariableReference", false, new String[]{})).where(new IWhereFilter<SNode>() {
            public boolean accept(SNode it) {
              return SetSequence.fromSet(MapSequence.fromMap(aliases).get(node)).contains(BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), it, "virtual_getVariable_2486081302460156153", new Object[]{}));
            }
          })) {
            SetSequence.fromSet(MapSequence.fromMap(aliases).get(ref)).addSequence(SetSequence.fromSet(MapSequence.fromMap(aliases).get(node)));
          }
        }
      }
    }

    return aliases;
  }



  /**
   * Remove sync ressources whose referred variables are already synchronized in the current context.
   * Disregard definite aliases as they should rarely occur (=> are of minor importance), e.g.:
   *   shared(int32) x;
   *   shared(int32)* y = &x;
   *   sync(x) { sync(y) {
   *       x.set(1); y.set(2);
   *   }}
   * Or: suppose, that definite aliases exist (but do not implement their construction).
   */
  public void removeRecursiveLocks(Map<SNode, Set<SNode>> dataflowGraph, Map<SNode, Set<SNode>> inverseDataflowGraph, final Map<SNode, Set<SNode>> aliases, List<SNode> syncResources, SNode entryFunction, Map<SNode, Set<SNode>> callGraph) {
    final Set<SNode> syncedNodes = SetSequence.fromSet(new HashSet<SNode>());

    for (SNode syncResource : ListSequence.fromList(syncResources)) {
      if (SNodeOperations.getParent(syncResource) == null) {
        continue;
      }

      final SNode syncResourceRef = getVariableRef(SLinkOperations.getTarget(syncResource, "expression", true));
      final SNode syncResourceVariable = getVariable(SLinkOperations.getTarget(syncResource, "expression", true));
      final Set<SNode> syncResourceAliases = MapSequence.fromMap(aliases).get(syncResourceRef);

      // in the current sync context mark every reference which refers to equal variables as the sync ressource's 
      // reference does as synced 
      SNode sync = SNodeOperations.getAncestor(syncResource, "TasksAndSyncs.structure.SyncStatement", false, false);
      for (SNode equalReference : ListSequence.fromList(SNodeOperations.getDescendants(sync, "com.mbeddr.core.statements.structure.IVariableReference", false, new String[]{})).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode otherRef) {
          SNode otherRefVariable = getVariable(SNodeOperations.cast(otherRef, "com.mbeddr.core.expressions.structure.Expression"));
          Set<SNode> otherRefAliases = MapSequence.fromMap(aliases).get(getVariableRef(SNodeOperations.cast(otherRef, "com.mbeddr.core.expressions.structure.Expression")));
          return syncResourceRef != otherRef && (syncResourceVariable == otherRefVariable || SetSequence.fromSet(syncResourceAliases).containsSequence(SetSequence.fromSet(otherRefAliases)) && SetSequence.fromSet(otherRefAliases).containsSequence(SetSequence.fromSet(syncResourceAliases)));
        }
      })) {
        SetSequence.fromSet(syncedNodes).addElement(equalReference);
      }
    }

    // let the sync context of the current variable flow as far as possible through the graph 
    // ...disregard cycles 
    activateSyncForNodes(syncedNodes, dataflowGraph, inverseDataflowGraph);
    // remove sync resources whose references have a sync context 
    ListSequence.fromList(syncResources).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SetSequence.fromSet(syncedNodes).contains(SLinkOperations.getTarget(it, "expression", true));
      }
    }).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        SNodeOperations.deleteNode(it);
      }
    });
  }



  public boolean activateSyncForNodes(final Set<SNode> syncedNodes, Map<SNode, Set<SNode>> dataflowGraph, Map<SNode, Set<SNode>> inverseDataflowGraph) {
    boolean foundAnything = false;
    boolean foundSomething = true;
    while (foundSomething) {
      foundSomething = false;
      List<SNode> activatedNodes = new ArrayList<SNode>();
      for (SNode node : SetSequence.fromSet(syncedNodes)) {
        for (SNode nextNode : SetSequence.fromSet(MapSequence.fromMap(dataflowGraph).get(node)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return !(SetSequence.fromSet(syncedNodes).contains(it));
          }
        })) {
          // this does not work for cycles but for every other structure: 
          // if every incoming value/node (relevant for function arguments (and returns, in the future)) is 
          // synced, then so must be the current node 
          if (SetSequence.fromSet(MapSequence.fromMap(inverseDataflowGraph).get(nextNode)).all(new IWhereFilter<SNode>() {
            public boolean accept(SNode it) {
              return SetSequence.fromSet(syncedNodes).contains(it);
            }
          })) {
            foundSomething = foundAnything = true;
            ListSequence.fromList(activatedNodes).addElement(nextNode);
          }
        }
      }
      SetSequence.fromSet(syncedNodes).addSequence(ListSequence.fromList(activatedNodes));
    }
    return foundAnything;
  }



  public static   enum FlowChangeMode {
    activate(),
    deactivate();

  }



  public Set<SNode> flowSyncForNodes(final Set<SNode> syncedNodes, Map<SNode, Set<SNode>> taskSeparatedDataflowGraph, Map<SNode, Set<SNode>> inverseDataflowGraph, final Optimizer.FlowChangeMode mode) {
    Set<SNode> allChangedNodes = SetSequence.fromSet(new HashSet<SNode>());
    boolean foundSomething = true;
    while (foundSomething) {
      foundSomething = false;
      List<SNode> changedNodes = new ArrayList<SNode>();
      for (SNode node : SetSequence.fromSet(syncedNodes)) {
        for (SNode nextNode : SetSequence.fromSet(MapSequence.fromMap(taskSeparatedDataflowGraph).get(node)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return (mode == Optimizer.FlowChangeMode.activate) != SetSequence.fromSet(syncedNodes).contains(it);
          }
        })) {
          if (mode == Optimizer.FlowChangeMode.activate && SNodeOperations.isInstanceOf(nextNode, "com.mbeddr.core.modules.structure.Argument")) {
            System.out.println("(active) check argument " + SPropertyOperations.getString(SNodeOperations.cast(nextNode, "com.mbeddr.core.modules.structure.Argument"), "name"));
            SetSequence.fromSet(MapSequence.fromMap(inverseDataflowGraph).get(nextNode)).visitAll(new IVisitor<SNode>() {
              public void visit(SNode it) {
                System.out.println("--> in: " + it + " : " + SNodeOperations.getConceptDeclaration(it));
              }
            });
          }
          // this does not work for cycles but for every other structure: 
          // if every incoming value/node (relevant for function arguments (and returns, in the future)) is 
          // synced, then so must be the current node 
          if (mode == Optimizer.FlowChangeMode.activate) {
            if (SetSequence.fromSet(MapSequence.fromMap(inverseDataflowGraph).get(nextNode)).all(new IWhereFilter<SNode>() {
              public boolean accept(SNode it) {
                return SetSequence.fromSet(syncedNodes).contains(it);
              }
            })) {
              foundSomething = true;
              ListSequence.fromList(changedNodes).addElement(nextNode);
            }
          } else {
            if (SetSequence.fromSet(MapSequence.fromMap(inverseDataflowGraph).get(nextNode)).any(new IWhereFilter<SNode>() {
              public boolean accept(SNode it) {
                return !(SetSequence.fromSet(syncedNodes).contains(it));
              }
            })) {
              foundSomething = true;
              ListSequence.fromList(changedNodes).addElement(nextNode);
            }
          }
        }
      }
      if (mode == Optimizer.FlowChangeMode.activate) {
        SetSequence.fromSet(syncedNodes).addSequence(ListSequence.fromList(changedNodes));
      } else {
        SetSequence.fromSet(syncedNodes).removeSequence(ListSequence.fromList(changedNodes));
      }
      SetSequence.fromSet(allChangedNodes).addSequence(ListSequence.fromList(changedNodes));
    }
    return allChangedNodes;
  }



  public Map<SNode, Set<SNode>> invertDataflowGraph(Map<SNode, Set<SNode>> dataflowGraph) {
    Map<SNode, Set<SNode>> inverseDataflowGraph = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());
    for (IMapping<SNode, Set<SNode>> nodeToOthers : MapSequence.fromMap(dataflowGraph)) {
      for (SNode other : SetSequence.fromSet(nodeToOthers.value())) {
        if (!(MapSequence.fromMap(inverseDataflowGraph).containsKey(other))) {
          MapSequence.fromMap(inverseDataflowGraph).put(other, SetSequence.fromSet(new HashSet<SNode>()));
        }
        SetSequence.fromSet(MapSequence.fromMap(inverseDataflowGraph).get(other)).addElement(nodeToOthers.key());
      }
    }
    return inverseDataflowGraph;
  }



  public Map<SNode, Set<SNode>> separateDataflowGraphByTasks(Map<SNode, Set<SNode>> dataflowGraph) {
    Map<SNode, Set<SNode>> taskSeparatedDataflowGraph = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());
    for (final SNode fromNode : SetSequence.fromSet(MapSequence.fromMap(dataflowGraph).keySet())) {
      MapSequence.fromMap(taskSeparatedDataflowGraph).put(fromNode, SetSequence.fromSet(new HashSet<SNode>()));
      for (SNode toNode : SetSequence.fromSet(MapSequence.fromMap(dataflowGraph).get(fromNode)).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode toNode) {
          SNode fromContext = getNearestContext(fromNode);
          SNode toContext = getNearestContext(toNode);
          return fromContext == toContext || SNodeOperations.isInstanceOf(fromContext, "com.mbeddr.core.modules.structure.Function") && SNodeOperations.isInstanceOf(toContext, "com.mbeddr.core.modules.structure.Function");
        }
      })) {
        SetSequence.fromSet(MapSequence.fromMap(taskSeparatedDataflowGraph).get(fromNode)).addElement(toNode);
      }
    }
    return taskSeparatedDataflowGraph;
  }



  public SNode getNearestContext(SNode node) {
    SNode surroundingTask = SNodeOperations.getAncestor(node, "TasksAndSyncs.structure.Task", false, false);
    if ((surroundingTask != null)) {
      return surroundingTask;
    }
    return SNodeOperations.getAncestor(node, "com.mbeddr.core.modules.structure.Function", false, false);
  }



  /**
   * Remove sync resources for variables that are only read (directly or via some alias).
   */
  public void removeReadonlyLocks(final Map<SNode, Set<SNode>> aliases, List<SNode> syncResources, List<SNode> variables, List<SNode> sharedSets, List<SNode> sharedGets, List<SNode> allFunctionCalls) {

    Set<SNode> readOnlyVariables = SetSequence.fromSet(new HashSet<SNode>());

    for (final SNode variable : ListSequence.fromList(variables)) {
      // if no modifying expression exists for the current variable v (v.set or v.get... = ...) 
      // every synchronization for v is redundant 
      boolean modifiesViaSet = ListSequence.fromList(sharedSets).any(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SetSequence.fromSet(MapSequence.fromMap(aliases).get(getVariableRef(SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(it), "com.mbeddr.core.expressions.structure.GenericDotExpression"), "expression", true)))).contains(variable);
        }
      });
      boolean modifiesViaGet = ListSequence.fromList(sharedGets).any(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SetSequence.fromSet(MapSequence.fromMap(aliases).get(getVariableRef(SLinkOperations.getTarget(SNodeOperations.cast(SNodeOperations.getParent(it), "com.mbeddr.core.expressions.structure.GenericDotExpression"), "expression", true)))).contains(variable) && (SNodeOperations.getAncestor(it, "com.mbeddr.core.expressions.structure.AssignmentExpr", false, false) != null) && ListSequence.fromList(SNodeOperations.getDescendants(SLinkOperations.getTarget(SNodeOperations.getAncestor(it, "com.mbeddr.core.expressions.structure.AssignmentExpr", false, false), "left", true), "TasksAndSyncs.structure.SharedGet", false, new String[]{})).contains(it);
        }
      });
      if (modifiesViaSet || modifiesViaGet) {
        continue;
      }

      SetSequence.fromSet(readOnlyVariables).addElement(variable);
    }

    removeSyncResourceLocks(aliases, syncResources, readOnlyVariables, allFunctionCalls);
  }



  /**
   * Remove sync resources for variables that are never shared with other tasks, e.g. due to reuse of library
   * functions.
   */
  public void removeSingleTaskLocks(final Map<SNode, Set<SNode>> aliases, final Map<SNode, Set<SNode>> dataflowGraph, List<SNode> syncResources, List<SNode> variables, List<SNode> variableReferences, List<SNode> allFunctionCalls) {

    Set<SNode> singleTaskVariables = SetSequence.fromSet(new HashSet<SNode>());

    for (final SNode variable : ListSequence.fromList(variables)) {
      // if the current variable v is never shared with any task every synchronization for v is redundant 
      // => skip the variable if it is shared with another task 
      if (SetSequence.fromSet(MapSequence.fromMap(dataflowGraph).keySet()).any(new IWhereFilter<SNode>() {
        public boolean accept(final SNode from) {
          return SetSequence.fromSet(MapSequence.fromMap(aliases).get(from)).contains(variable) && SetSequence.fromSet(MapSequence.fromMap(dataflowGraph).get(from)).any(new IWhereFilter<SNode>() {
            public boolean accept(SNode to) {
              SNode fromContext = getNearestContext(from);
              SNode toContext = getNearestContext(to);
              return SetSequence.fromSet(MapSequence.fromMap(aliases).get(to)).contains(variable) && SNodeOperations.isInstanceOf(toContext, "TasksAndSyncs.structure.Task") && fromContext != toContext;
            }
          });
        }
      })) {
        continue;
      }

      SetSequence.fromSet(singleTaskVariables).addElement(variable);
    }

    removeSyncResourceLocks(aliases, syncResources, singleTaskVariables, allFunctionCalls);
  }



  public void removeSyncResourceLocks(Map<SNode, Set<SNode>> aliases, List<SNode> syncResources, Set<SNode> cleanVariables, List<SNode> allFunctionCalls) {
    Map<SNode, Set<SNode>> functionToConflictingSyncResources = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());

    for (SNode syncResource : ListSequence.fromList(syncResources)) {
      if (SetSequence.fromSet(cleanVariables).containsSequence(SetSequence.fromSet(MapSequence.fromMap(aliases).get(getVariableRef(SLinkOperations.getTarget(syncResource, "expression", true)))))) {
        SNodeOperations.deleteNode(syncResource);
      } else {
        SNode function = SNodeOperations.getAncestor(syncResource, "com.mbeddr.core.modules.structure.Function", false, false);
        if (!(MapSequence.fromMap(functionToConflictingSyncResources).containsKey(function))) {
          MapSequence.fromMap(functionToConflictingSyncResources).put(function, SetSequence.fromSet(new HashSet<SNode>()));
        }
        SetSequence.fromSet(MapSequence.fromMap(functionToConflictingSyncResources).get(function)).addElement(syncResource);
      }
    }

    for (SNode function : SetSequence.fromSet(MapSequence.fromMap(functionToConflictingSyncResources).keySet())) {
      tryToInline(aliases, syncResources, cleanVariables, MapSequence.fromMap(functionToConflictingSyncResources).get(function), allFunctionCalls);
    }
  }



  public void tryToInline(Map<SNode, Set<SNode>> aliases, List<SNode> syncResources, final Set<SNode> cleanVariables, Set<SNode> conflictingSyncResources, List<SNode> allFunctionCalls) {
    final SNode currentFunction = SNodeOperations.getAncestor(SetSequence.fromSet(conflictingSyncResources).first(), "com.mbeddr.core.modules.structure.Function", false, false);
    Set<SNode> currentFunctionCalls = SetSequence.fromSetWithValues(new HashSet<SNode>(), ListSequence.fromList(allFunctionCalls).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SLinkOperations.getTarget(it, "function", false) == currentFunction;
      }
    }));

    final Map<SNode, Set<SNode>> callToCleanSyncs = MapSequence.fromMap(new HashMap<SNode, Set<SNode>>());
    SetSequence.fromSet(currentFunctionCalls).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        MapSequence.fromMap(callToCleanSyncs).put(it, SetSequence.fromSet(new HashSet<SNode>()));
      }
    });

    // create batches of tightly coupled calls of the current function f, i.e. for every call in a batch  
    // every argument in this call that is used by some sync in f has only clean aliases 
    for (final SNode conflictingSyncResource : SetSequence.fromSet(conflictingSyncResources)) {
      List<SNode> dirtyAliases = SetSequence.fromSet(MapSequence.fromMap(aliases).get(getVariableRef(SLinkOperations.getTarget(conflictingSyncResource, "expression", true)))).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return !(SetSequence.fromSet(cleanVariables).contains(it));
        }
      }).toListSequence();
      Set<SNode> cleanCalls = getCleanCalls(aliases, dirtyAliases, currentFunction, currentFunctionCalls, conflictingSyncResource);
      if (cleanCalls == null) {
        continue;
      }

      SetSequence.fromSet(cleanCalls).visitAll(new IVisitor<SNode>() {
        public void visit(SNode it) {
          SetSequence.fromSet(MapSequence.fromMap(callToCleanSyncs).get(it)).addElement(conflictingSyncResource);
        }
      });
    }

    final Map<Set<SNode>, Set<SNode>> cleanSyncsToCalls = MapSequence.fromMap(new HashMap<Set<SNode>, Set<SNode>>());
    for (IMapping<SNode, Set<SNode>> callAndCleanSyncs : MapSequence.fromMap(callToCleanSyncs).where(new IWhereFilter<IMapping<SNode, Set<SNode>>>() {
      public boolean accept(IMapping<SNode, Set<SNode>> it) {
        return SetSequence.fromSet(it.value()).isNotEmpty();
      }
    })) {
      if (!(MapSequence.fromMap(cleanSyncsToCalls).containsKey(callAndCleanSyncs.value()))) {
        MapSequence.fromMap(cleanSyncsToCalls).put(callAndCleanSyncs.value(), SetSequence.fromSet(new HashSet<SNode>()));
      }
      SetSequence.fromSet(MapSequence.fromMap(cleanSyncsToCalls).get(callAndCleanSyncs.value())).addElement(callAndCleanSyncs.key());
    }
    SetSequence.fromSet(MapSequence.fromMap(cleanSyncsToCalls).keySet()).visitAll(new IVisitor<Set<SNode>>() {
      public void visit(Set<SNode> it) {
        copyFunctionForCalls(currentFunction, MapSequence.fromMap(cleanSyncsToCalls).get(it), it);
      }
    });
  }



  public Set<SNode> getCleanCalls(final Map<SNode, Set<SNode>> aliases, List<SNode> dirtyAliases, SNode function, Set<SNode> callsForFunction, SNode syncResource) {
    // ensure that the dirty aliases of the syncResource all come from one argument; otherwise 
    // it is useless to inline the function since the source of evil resides in the function itself... 
    if (!(SNodeOperations.isInstanceOf(getVariable(SLinkOperations.getTarget(syncResource, "expression", true)), "com.mbeddr.core.modules.structure.Argument"))) {
      return null;
    }
    if (!(SetSequence.fromSet(MapSequence.fromMap(aliases).get(getVariable(SLinkOperations.getTarget(syncResource, "expression", true)))).containsSequence(ListSequence.fromList(dirtyAliases)))) {
      return null;
    }

    Set<SNode> cleanCalls = SetSequence.fromSet(new HashSet<SNode>());
    SetSequence.fromSet(cleanCalls).addSequence(SetSequence.fromSet(callsForFunction));

    final SNode referredArgument = SNodeOperations.cast(getVariable(SLinkOperations.getTarget(syncResource, "expression", true)), "com.mbeddr.core.modules.structure.Argument");
    final int argumentIndex = ListSequence.fromList(SLinkOperations.getTargets(function, "arguments", true)).indexOf(referredArgument);
    for (final SNode dirtyAlias : ListSequence.fromList(dirtyAliases).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SetSequence.fromSet(MapSequence.fromMap(aliases).get(referredArgument)).contains(it);
      }
    })) {
      for (SNode call : SetSequence.fromSet(callsForFunction).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          SNode argumentVariableRef = getVariableRef(ListSequence.fromList(SLinkOperations.getTargets(it, "actuals", true)).getElement(argumentIndex));
          return argumentVariableRef != null && MapSequence.fromMap(aliases).containsKey(argumentVariableRef) && SetSequence.fromSet(MapSequence.fromMap(aliases).get(argumentVariableRef)).contains(dirtyAlias);
        }
      })) {
        if (SetSequence.fromSet(cleanCalls).contains(call)) {
          SetSequence.fromSet(cleanCalls).removeElement(call);
        }
      }
    }

    return cleanCalls;
  }



  public void copyFunctionForCalls(final SNode function, final Set<SNode> calls, Set<SNode> cleanSyncResources) {
    final Map<SNode, SNode> syncRessourceToExpression = MapSequence.fromMap(new HashMap<SNode, SNode>());
    SetSequence.fromSet(cleanSyncResources).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        MapSequence.fromMap(syncRessourceToExpression).put(it, SLinkOperations.getTarget(it, "expression", true));
        SLinkOperations.setTarget(it, "expression", null, true);
      }
    });
    ListSequence.fromList(SNodeOperations.getDescendants(function, "com.mbeddr.core.modules.structure.FunctionCall", false, new String[]{})).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SLinkOperations.getTarget(it, "function", false) == function && !(SetSequence.fromSet(calls).contains(it));
      }
    }).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        SLinkOperations.setTarget(it, "function", null, false);
      }
    });

    final SNode copiedFunction = SNodeOperations.copyNode(function);
    SPropertyOperations.set(copiedFunction, "name", genContext.createUniqueName(SPropertyOperations.getString(function, "name"), null));
    ListSequence.fromList(SNodeOperations.getDescendants(copiedFunction, "TasksAndSyncs.structure.SyncRessource", false, new String[]{})).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SLinkOperations.getTarget(it, "expression", true) == null;
      }
    }).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        SNodeOperations.deleteNode(it);
      }
    });
    ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.getAncestor(function, "com.mbeddr.core.modules.structure.ImplementationModule", false, false), "contents", true)).addElement(copiedFunction);

    SetSequence.fromSet(calls).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        SLinkOperations.setTarget(it, "function", copiedFunction, false);
      }
    });
    ListSequence.fromList(SNodeOperations.getDescendants(copiedFunction, "com.mbeddr.core.modules.structure.FunctionCall", false, new String[]{})).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SLinkOperations.getTarget(it, "function", false) == null;
      }
    }).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        SLinkOperations.setTarget(it, "function", function, false);
      }
    });
    ListSequence.fromList(SNodeOperations.getDescendants(function, "com.mbeddr.core.modules.structure.FunctionCall", false, new String[]{})).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return SLinkOperations.getTarget(it, "function", false) == null;
      }
    }).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        SLinkOperations.setTarget(it, "function", function, false);
      }
    });
    SetSequence.fromSet(cleanSyncResources).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        SLinkOperations.setTarget(it, "expression", MapSequence.fromMap(syncRessourceToExpression).get(it), true);
      }
    });
  }



  /**
   * Remove sync ressources for variables that are only read (directly or via some alias).
   */
  public void narrowSyncs(Map<SNode, Set<SNode>> aliases, List<SNode> syncs) {
    for (SNode sync : ListSequence.fromList(syncs)) {
      // gather all variables whose shared ressources are synchronized by the current sync 
      // TODO: should be able to simplify by just checking references to the actual variable (not aliases) 
      final Set<SNode> syncResourceAliases = SetSequence.fromSet(new HashSet<SNode>());
      for (SNode syncRessource : ListSequence.fromList(SLinkOperations.getTargets(sync, "ressources", true))) {
        SNode variable = getVariable(SLinkOperations.getTarget(syncRessource, "expression", true));
        SetSequence.fromSet(syncResourceAliases).addElement(variable);
        // TODO: change to aliases[getReferences(syncResource.expression)]... 
        SetSequence.fromSet(MapSequence.fromMap(aliases).get(variable)).visitAll(new IVisitor<SNode>() {
          public void visit(SNode it) {
            SetSequence.fromSet(syncResourceAliases).addElement(SNodeOperations.cast(it, "com.mbeddr.core.statements.structure.IVariableDeclaration"));
          }
        });
      }

      // in order to keep the scopes and 'shadows' of variables all shifted statements and the  
      // sync itself are wrapped inside another block 
      SNode surroundingBlock;
      List<SNode> firstStatements = new ArrayList<SNode>();
      List<SNode> lastStatements = new ArrayList<SNode>();

      // shift every possible first statement out of sync (named resources need not be regarded as they 
      // are already desugared at this point) 
      for (SNode firstStatement : ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(sync, "body", true), "statements", true))) {
        boolean shiftIsUnsafe = ListSequence.fromList(SNodeOperations.getDescendants(firstStatement, "com.mbeddr.core.statements.structure.IVariableReference", false, new String[]{})).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return isSharedType(SNodeOperations.cast(TypeChecker.getInstance().getTypeOf(it), "com.mbeddr.core.expressions.structure.Type"));
          }
        }).any(new IWhereFilter<SNode>() {
          public boolean accept(SNode reference) {
            return SetSequence.fromSet(syncResourceAliases).contains(getVariable(SNodeOperations.cast(reference, "com.mbeddr.core.expressions.structure.Expression")));
          }
        });
        if (shiftIsUnsafe || isControlFlowBreak(firstStatement)) {
          break;
        }
        ListSequence.fromList(firstStatements).addElement(firstStatement);
      }

      // do the same for the last statements of sync 
      for (SNode lastStatement : ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(sync, "body", true), "statements", true)).reversedList()) {
        boolean shiftIsUnsafe = ListSequence.fromList(SNodeOperations.getDescendants(lastStatement, "com.mbeddr.core.statements.structure.IVariableReference", false, new String[]{})).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return isSharedType(SNodeOperations.cast(TypeChecker.getInstance().getTypeOf(it), "com.mbeddr.core.expressions.structure.Type"));
          }
        }).any(new IWhereFilter<SNode>() {
          public boolean accept(SNode reference) {
            return SetSequence.fromSet(syncResourceAliases).contains(getVariable(SNodeOperations.cast(reference, "com.mbeddr.core.expressions.structure.Expression")));
          }
        });
        if (shiftIsUnsafe) {
          break;
        }
        ListSequence.fromList(lastStatements).insertElement(0, lastStatement);
      }

      if (!(ListSequence.fromList(firstStatements).isEmpty()) || !(ListSequence.fromList(lastStatements).isEmpty())) {
        surroundingBlock = new _FunctionTypes._return_P0_E0<SNode>() {
          public SNode invoke() {
            SNode node_8220307879112385182 = new _FunctionTypes._return_P0_E0<SNode>() {
              public SNode invoke() {
                SNode res = SConceptOperations.createNewNode("com.mbeddr.core.statements.structure.StatementList", null);
                return res;
              }
            }.invoke();
            return node_8220307879112385182;
          }
        }.invoke();
        SNodeOperations.replaceWithAnother(sync, surroundingBlock);
        ListSequence.fromList(SLinkOperations.getTargets(surroundingBlock, "statements", true)).addSequence(ListSequence.fromList(firstStatements));
        ListSequence.fromList(SLinkOperations.getTargets(surroundingBlock, "statements", true)).addElement(sync);
        ListSequence.fromList(SLinkOperations.getTargets(surroundingBlock, "statements", true)).addSequence(ListSequence.fromList(lastStatements));
      }
    }
  }



  private boolean isControlFlowBreak(SNode statement) {
    return SNodeOperations.isInstanceOf(statement, "com.mbeddr.core.statements.structure.BreakStatement") || SNodeOperations.isInstanceOf(statement, "com.mbeddr.core.statements.structure.ContinueStatement") || SNodeOperations.isInstanceOf(statement, "com.mbeddr.core.modules.structure.GotoStatement") || SNodeOperations.isInstanceOf(statement, "com.mbeddr.core.modules.structure.ReturnStatement") || SNodeOperations.isInstanceOf(statement, "com.mbeddr.core.statements.structure.BreakStatement");
  }



  public List<SNode> getFunctionCalls() {
    List<SNode> functionCalls = new ArrayList<SNode>();
    for (SNode implementationModule : ListSequence.fromList(SModelOperations.getRoots(model, "com.mbeddr.core.modules.structure.ImplementationModule"))) {
      ListSequence.fromList(functionCalls).addSequence(ListSequence.fromList(SNodeOperations.getDescendants(implementationModule, "com.mbeddr.core.modules.structure.FunctionCall", false, new String[]{})));
    }
    return functionCalls;
  }



  public List<SNode> getSurroundingSyncs(SNode node) {
    final SNode surroundingTask = SNodeOperations.getAncestor(node, "TasksAndSyncs.structure.Task", false, false);
    if ((surroundingTask == null)) {
      return Sequence.fromIterable(SNodeOperations.ofConcept(SNodeOperations.getAncestors(node, null, false), "TasksAndSyncs.structure.SyncStatement")).toListSequence();
    }
    return Sequence.fromIterable(SNodeOperations.ofConcept(SNodeOperations.getAncestors(node, null, false), "TasksAndSyncs.structure.SyncStatement")).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return ListSequence.fromList(SNodeOperations.getAncestors(it, null, false)).contains(surroundingTask);
      }
    }).toListSequence();
  }



  public SNode getSyncForVariable(SNode variable, SNode referringNode) {
    List<SNode> surroundingSyncs = getSurroundingSyncs(referringNode);
    if (ListSequence.fromList(surroundingSyncs).isEmpty()) {
      return null;
    }
    for (SNode surroundingSync : ListSequence.fromList(surroundingSyncs)) {
      for (SNode surroundingSyncRessource : ListSequence.fromList(SLinkOperations.getTargets(surroundingSync, "ressources", true))) {
        SNode otherVariable = SyncRessource_Behavior.call_getVariable_1469333039370134366(surroundingSyncRessource);
        if (otherVariable != null && otherVariable == variable) {
          return surroundingSyncRessource;
        }
      }
    }
    return null;
  }



  public SNode getVariable(SNode expr) {
    if (SNodeOperations.isInstanceOf(expr, "com.mbeddr.core.statements.structure.LocalVarRef") || SNodeOperations.isInstanceOf(expr, "com.mbeddr.core.modules.structure.ArgumentRef")) {
      return BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), SNodeOperations.cast(expr, "com.mbeddr.core.statements.structure.IVariableReference"), "virtual_getVariable_2486081302460156153", new Object[]{});
    }
    if (SNodeOperations.isInstanceOf(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr") && (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr"), "expression", true), "com.mbeddr.core.statements.structure.LocalVarRef") || SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr"), "expression", true), "com.mbeddr.core.modules.structure.ArgumentRef"))) {
      return BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), SNodeOperations.cast(SLinkOperations.getTarget(SNodeOperations.cast(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr"), "expression", true), "com.mbeddr.core.statements.structure.IVariableReference"), "virtual_getVariable_2486081302460156153", new Object[]{});
    }
    return null;
  }



  public SNode getVariableRef(SNode expr) {
    if (SNodeOperations.isInstanceOf(expr, "com.mbeddr.core.statements.structure.LocalVarRef") || SNodeOperations.isInstanceOf(expr, "com.mbeddr.core.modules.structure.ArgumentRef")) {
      return SNodeOperations.cast(expr, "com.mbeddr.core.statements.structure.IVariableReference");
    }
    if (SNodeOperations.isInstanceOf(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr") && (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr"), "expression", true), "com.mbeddr.core.statements.structure.LocalVarRef") || SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr"), "expression", true), "com.mbeddr.core.modules.structure.ArgumentRef"))) {
      return SNodeOperations.cast(SLinkOperations.getTarget(SNodeOperations.cast(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr"), "expression", true), "com.mbeddr.core.statements.structure.IVariableReference");
    }
    return null;
  }
}
