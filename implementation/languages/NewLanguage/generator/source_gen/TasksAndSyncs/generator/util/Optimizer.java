package TasksAndSyncs.generator.util;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SModel;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.Set;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.IMapping;
import java.util.ArrayList;
import jetbrains.mps.typesystem.inference.TypeChecker;
import TasksAndSyncs.behavior.SyncRessource_Behavior;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.smodel.behaviour.BehaviorReflection;

public class Optimizer {

  /*package*/ SModel model;


  public void init(SModel model) {
    this.model = model;
  }




  /**
   * Only consider direct function calls, disregard function passes via parameters (like lambdas)
   */
  public Map<SNode, Set<Pair<SNode, List<SNode>>>> createCallGraph() {
    Map<SNode, Set<Pair<SNode, List<SNode>>>> functionToCalledFunctions = MapSequence.fromMap(new HashMap<SNode, Set<Pair<SNode, List<SNode>>>>());

    for (SNode implementationModule : ListSequence.fromList(SModelOperations.getRoots(model, "com.mbeddr.core.modules.structure.ImplementationModule"))) {
      for (SNode function : ListSequence.fromList(SNodeOperations.getDescendants(implementationModule, "com.mbeddr.core.modules.structure.Function", false, new String[]{}))) {
        for (SNode functionCall : ListSequence.fromList(SNodeOperations.getDescendants(function, "com.mbeddr.core.modules.structure.FunctionCall", false, new String[]{})).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return (SNodeOperations.getAncestor(it, "com.mbeddr.core.modules.structure.Closure", false, false) == null) && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, "function", false), "com.mbeddr.core.modules.structure.Function");
          }
        })) {
          if (!(MapSequence.fromMap(functionToCalledFunctions).containsKey(function))) {
            MapSequence.fromMap(functionToCalledFunctions).put(function, SetSequence.fromSet(new HashSet<Pair<SNode, List<SNode>>>()));
          }
          SetSequence.fromSet(MapSequence.fromMap(functionToCalledFunctions).get(function)).addElement(new Pair(SNodeOperations.cast(SLinkOperations.getTarget(functionCall, "function", false), "com.mbeddr.core.modules.structure.Function"), functionCall));
        }
      }
    }

    return functionToCalledFunctions;
  }



  public Map<SNode, Set<Pair<SNode, List<SNode>>>> createDeepCallGraph() {
    Map<SNode, Set<Pair<SNode, List<SNode>>>> functionToCalledFunctions = createCallGraph();
    final Map<SNode, Set<Pair<SNode, List<SNode>>>> functionToDeeplyCalledFunctions = MapSequence.fromMap(new HashMap<SNode, Set<Pair<SNode, List<SNode>>>>());

    MapSequence.fromMap(functionToCalledFunctions).visitAll(new IVisitor<IMapping<SNode, Set<Pair<SNode, List<SNode>>>>>() {
      public void visit(IMapping<SNode, Set<Pair<SNode, List<SNode>>>> it) {
        MapSequence.fromMap(functionToDeeplyCalledFunctions).put(it.key(), SetSequence.fromSet(new HashSet<Pair<SNode, List<SNode>>>()));
        SetSequence.fromSet(MapSequence.fromMap(functionToDeeplyCalledFunctions).get(it.key())).addSequence(SetSequence.fromSet(it.value()));
      }
    });

    // should happen O(n) times 
    while (true) {
      boolean anyChangeHappened = false;
      // O(n) 
      for (final IMapping<SNode, Set<Pair<SNode, List<SNode>>>> functionAndDeeplyCalledFunctions : MapSequence.fromMap(functionToDeeplyCalledFunctions)) {
        boolean changeForFunctionHappened = false;
        Set<Pair<SNode, List<SNode>>> nextCalledFunctions = SetSequence.fromSet(new HashSet<Pair<SNode, List<SNode>>>());
        // O(n) 
        for (Pair<SNode, List<SNode>> currentCalledFunction : SetSequence.fromSet(functionAndDeeplyCalledFunctions.value()).where(new IWhereFilter<Pair<SNode, List<SNode>>>() {
          public boolean accept(Pair<SNode, List<SNode>> it) {
            return it.first != functionAndDeeplyCalledFunctions.key();
          }
        })) {
          // O(n) 
          for (Pair<SNode, List<SNode>> nextCalledFunction : SetSequence.fromSet(MapSequence.fromMap(functionToDeeplyCalledFunctions).get(currentCalledFunction.first))) {
            // O(log(n)) or O(1) 
            if (!(SetSequence.fromSet(functionAndDeeplyCalledFunctions.value()).contains(nextCalledFunction))) {
              anyChangeHappened = changeForFunctionHappened = true;
              List<SNode> pathToNextCalledFunction = new ArrayList<SNode>();
              ListSequence.fromList(pathToNextCalledFunction).addSequence(ListSequence.fromList(currentCalledFunction.second));
              ListSequence.fromList(pathToNextCalledFunction).addSequence(ListSequence.fromList(nextCalledFunction.second));
              SetSequence.fromSet(nextCalledFunctions).addElement(new Pair(nextCalledFunction, pathToNextCalledFunction));
            }
          }
        }
        if (changeForFunctionHappened) {
          SetSequence.fromSet(nextCalledFunctions).addSequence(SetSequence.fromSet(functionAndDeeplyCalledFunctions.value()));
          MapSequence.fromMap(functionToDeeplyCalledFunctions).put(functionAndDeeplyCalledFunctions.key(), nextCalledFunctions);
        }
      }
      if (!(anyChangeHappened)) {
        break;
      }
    }

    return functionToDeeplyCalledFunctions;
  }



  public boolean callGraphContainsCycles(Map<SNode, Set<Pair<SNode, List<SNode>>>> functionToDeeplyCalledFunctions) {
    return MapSequence.fromMap(functionToDeeplyCalledFunctions).any(new IWhereFilter<IMapping<SNode, Set<Pair<SNode, List<SNode>>>>>() {
      public boolean accept(final IMapping<SNode, Set<Pair<SNode, List<SNode>>>> it) {
        return SetSequence.fromSet(it.value()).any(new IWhereFilter<Pair<SNode, List<SNode>>>() {
          public boolean accept(Pair<SNode, List<SNode>> calledFunction) {
            return it.key() == calledFunction.first;
          }
        });
      }
    });
  }



  public void findSyncStates(Map<SNode, Map<SNode, Boolean>> nodeToReferencedNodes, Set<SNode> nodesWithUnknownStates) {
    List<SNode> functionCalls = getFunctionCalls();

    initSyncStatesForArguments(nodeToReferencedNodes, nodesWithUnknownStates, functionCalls);
    initSyncStatesForLocalVariables(nodeToReferencedNodes, nodesWithUnknownStates, functionCalls);
    initSyncStatesForSyncRessources(nodeToReferencedNodes, nodesWithUnknownStates, functionCalls);
    initSyncStatesForVariableRefs(nodeToReferencedNodes, nodesWithUnknownStates, functionCalls);

    passSyncStates(nodeToReferencedNodes, nodesWithUnknownStates);
  }



  public void initSyncStatesForArguments(Map<SNode, Map<SNode, Boolean>> nodeToReferencedNodes, Set<SNode> nodesWithUnknownStates, List<SNode> functionCalls) {
    for (SNode implementationModule : ListSequence.fromList(SModelOperations.getRoots(model, "com.mbeddr.core.modules.structure.ImplementationModule"))) {
      for (final SNode function : ListSequence.fromList(SNodeOperations.getDescendants(implementationModule, "com.mbeddr.core.modules.structure.Function", false, new String[]{}))) {
        for (SNode argument : ListSequence.fromList(SLinkOperations.getTargets(function, "arguments", true)).where(new IWhereFilter<SNode>() {
          public boolean accept(SNode it) {
            return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, "type", true), "TasksAndSyncs.structure.SharedType") || SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, "type", true), "com.mbeddr.core.pointers.structure.PointerType") && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(it, "type", true), "com.mbeddr.core.pointers.structure.PointerType"), "baseType", true), "TasksAndSyncs.structure.SharedType");
          }
        })) {
          MapSequence.fromMap(nodeToReferencedNodes).put(argument, MapSequence.fromMap(new HashMap<SNode, Boolean>()));
          for (SNode call : ListSequence.fromList(functionCalls).where(new IWhereFilter<SNode>() {
            public boolean accept(SNode it) {
              return SLinkOperations.getTarget(it, "function", false) == function;
            }
          })) {
            SNode argumentValue = ListSequence.fromList(SLinkOperations.getTargets(call, "actuals", true)).getElement(ListSequence.fromList(SLinkOperations.getTargets(function, "arguments", true)).indexOf(argument));
            Pair<SNode, SNode> variableAndSyncRessource = getVariableAndSyncRessource(argumentValue);
            if ((variableAndSyncRessource.second != null)) {
              MapSequence.fromMap(MapSequence.fromMap(nodeToReferencedNodes).get(argument)).put(variableAndSyncRessource.second, true);
            } else if ((variableAndSyncRessource.first != null)) {
              MapSequence.fromMap(MapSequence.fromMap(nodeToReferencedNodes).get(argument)).put(variableAndSyncRessource.first, false);
            } else {
              SetSequence.fromSet(nodesWithUnknownStates).addElement(argument);
              break;
            }
          }
        }
      }
    }
  }



  public void initSyncStatesForLocalVariables(Map<SNode, Map<SNode, Boolean>> nodeToReferencedNodes, Set<SNode> nodesWithUnknownStates, List<SNode> functionCalls) {
    for (SNode implementationModule : ListSequence.fromList(SModelOperations.getRoots(model, "com.mbeddr.core.modules.structure.ImplementationModule"))) {
      for (SNode localVariable : ListSequence.fromList(SNodeOperations.getDescendants(implementationModule, "com.mbeddr.core.statements.structure.LocalVariableDeclaration", false, new String[]{})).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, "type", true), "TasksAndSyncs.structure.SharedType");
        }
      })) {
        MapSequence.fromMap(nodeToReferencedNodes).put(localVariable, MapSequence.fromMap(new HashMap<SNode, Boolean>()));
      }

      for (SNode localVariable : ListSequence.fromList(SNodeOperations.getDescendants(implementationModule, "com.mbeddr.core.statements.structure.LocalVariableDeclaration", false, new String[]{})).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, "type", true), "com.mbeddr.core.pointers.structure.PointerType") && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(SLinkOperations.getTarget(it, "type", true), "com.mbeddr.core.pointers.structure.PointerType"), "baseType", true), "TasksAndSyncs.structure.SharedType");
        }
      })) {
        MapSequence.fromMap(nodeToReferencedNodes).put(localVariable, MapSequence.fromMap(new HashMap<SNode, Boolean>()));
        Pair<SNode, SNode> variableAndSyncRessource = getVariableAndSyncRessource(SLinkOperations.getTarget(localVariable, "init", true));
        if ((variableAndSyncRessource.second != null)) {
          MapSequence.fromMap(MapSequence.fromMap(nodeToReferencedNodes).get(localVariable)).put(variableAndSyncRessource.second, true);
        } else if ((variableAndSyncRessource.first != null)) {
          MapSequence.fromMap(MapSequence.fromMap(nodeToReferencedNodes).get(localVariable)).put(variableAndSyncRessource.first, true);
        } else {
          SetSequence.fromSet(nodesWithUnknownStates).addElement(localVariable);
        }
      }
    }
  }



  public void initSyncStatesForVariableRefs(Map<SNode, Map<SNode, Boolean>> nodeToReferencedNodes, Set<SNode> nodesWithUnknownStates, List<SNode> functionCalls) {
    for (SNode implementationModule : ListSequence.fromList(SModelOperations.getRoots(model, "com.mbeddr.core.modules.structure.ImplementationModule"))) {
      for (SNode variableRef : ListSequence.fromList(SNodeOperations.getDescendants(implementationModule, "com.mbeddr.core.statements.structure.IVariableReference", false, new String[]{})).where(new IWhereFilter<SNode>() {
        public boolean accept(SNode it) {
          return SNodeOperations.isInstanceOf(TypeChecker.getInstance().getTypeOf(it), "TasksAndSyncs.structure.SharedType") || SNodeOperations.isInstanceOf(TypeChecker.getInstance().getTypeOf(it), "com.mbeddr.core.pointers.structure.PointerType") && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(TypeChecker.getInstance().getTypeOf(it), "com.mbeddr.core.pointers.structure.PointerType"), "baseType", true), "TasksAndSyncs.structure.SharedType");
        }
      })) {
        MapSequence.fromMap(nodeToReferencedNodes).put(variableRef, MapSequence.fromMap(new HashMap<SNode, Boolean>()));
        Pair<SNode, SNode> variableAndSyncRessource = getVariableAndSyncRessource(SNodeOperations.cast(variableRef, "com.mbeddr.core.expressions.structure.Expression"));
        if ((variableAndSyncRessource.second != null)) {
          MapSequence.fromMap(MapSequence.fromMap(nodeToReferencedNodes).get(variableRef)).put(variableAndSyncRessource.second, true);
        } else if ((variableAndSyncRessource.first != null)) {
          MapSequence.fromMap(MapSequence.fromMap(nodeToReferencedNodes).get(variableRef)).put(variableAndSyncRessource.first, true);
        } else {
          SetSequence.fromSet(nodesWithUnknownStates).addElement(variableRef);
        }
      }
    }
  }



  public void initSyncStatesForSyncRessources(Map<SNode, Map<SNode, Boolean>> nodeToReferencedNodes, Set<SNode> nodesWithUnknownStates, List<SNode> functionCalls) {
    for (SNode implementationModule : ListSequence.fromList(SModelOperations.getRoots(model, "com.mbeddr.core.modules.structure.ImplementationModule"))) {
      for (SNode sync : ListSequence.fromList(SNodeOperations.getDescendants(implementationModule, "TasksAndSyncs.structure.SyncStatement", false, new String[]{}))) {
        for (SNode syncRessource : ListSequence.fromList(SLinkOperations.getTargets(sync, "ressources", true))) {
          MapSequence.fromMap(nodeToReferencedNodes).put(syncRessource, MapSequence.fromMap(new HashMap<SNode, Boolean>()));
          SNode referredVariable = SyncRessource_Behavior.call_getVariable_1469333039370134366(syncRessource);
          if (SNodeOperations.isInstanceOf(referredVariable, "com.mbeddr.core.modules.structure.GlobalVariableDeclaration") || SetSequence.fromSet(nodesWithUnknownStates).contains(referredVariable)) {
            SetSequence.fromSet(nodesWithUnknownStates).addElement(syncRessource);
          } else {
            SNode surroundingSyncRessource = getSyncForVariable(referredVariable, sync);
            if (surroundingSyncRessource != null) {
              MapSequence.fromMap(MapSequence.fromMap(nodeToReferencedNodes).get(syncRessource)).put(surroundingSyncRessource, true);
            } else {
              MapSequence.fromMap(MapSequence.fromMap(nodeToReferencedNodes).get(syncRessource)).put(referredVariable, false);
            }
          }
        }
      }
    }
  }



  public void passSyncStates(Map<SNode, Map<SNode, Boolean>> nodeToReferencedNodes, Set<SNode> nodesWithUnknownState) {
    boolean changedSomething = true;

    while (changedSomething) {
      changedSomething = false;
      for (IMapping<SNode, Map<SNode, Boolean>> nodeAndReferencedNodes : MapSequence.fromMap(nodeToReferencedNodes)) {
        for (IMapping<SNode, Boolean> referencedNode : MapSequence.fromMap(nodeAndReferencedNodes.value())) {
          if (!(SetSequence.fromSet(nodesWithUnknownState).contains(nodeAndReferencedNodes.key())) && SetSequence.fromSet(nodesWithUnknownState).contains(referencedNode.key())) {
            SetSequence.fromSet(nodesWithUnknownState).addElement(nodeAndReferencedNodes.key());
            changedSomething = true;
            break;
          }
          // Are all entries for the referenced value positive? 
          if ((Boolean) MapSequence.fromMap(nodeAndReferencedNodes.value()).get(referencedNode.key()) == false && Sequence.fromIterable(MapSequence.fromMap(MapSequence.fromMap(nodeToReferencedNodes).get(referencedNode.key())).values()).all(new IWhereFilter<Boolean>() {
            public boolean accept(Boolean it) {
              return it;
            }
          })) {
            // Then the referenced value itself must be positive... 
            MapSequence.fromMap(nodeAndReferencedNodes.value()).put(referencedNode.key(), true);
            changedSomething = true;
          }
        }
      }
    }
  }



  public List<SNode> getFunctionCalls() {
    List<SNode> functionCalls = new ArrayList<SNode>();
    for (SNode implementationModule : ListSequence.fromList(SModelOperations.getRoots(model, "com.mbeddr.core.modules.structure.ImplementationModule"))) {
      ListSequence.fromList(functionCalls).addSequence(ListSequence.fromList(SNodeOperations.getDescendants(implementationModule, "com.mbeddr.core.modules.structure.FunctionCall", false, new String[]{})));
    }
    return functionCalls;
  }



  public List<SNode> getSurroundingSyncs(SNode node) {
    final SNode surroundingTask = SNodeOperations.getAncestor(node, "TasksAndSyncs.structure.Task", false, false);
    if ((surroundingTask == null)) {
      return Sequence.fromIterable(SNodeOperations.ofConcept(SNodeOperations.getAncestors(node, null, false), "TasksAndSyncs.structure.SyncStatement")).toListSequence();
    }
    return Sequence.fromIterable(SNodeOperations.ofConcept(SNodeOperations.getAncestors(node, null, false), "TasksAndSyncs.structure.SyncStatement")).where(new IWhereFilter<SNode>() {
      public boolean accept(SNode it) {
        return ListSequence.fromList(SNodeOperations.getAncestors(it, null, false)).contains(surroundingTask);
      }
    }).toListSequence();
  }



  public SNode getSyncForVariable(SNode variable, SNode referringNode) {
    List<SNode> surroundingSyncs = getSurroundingSyncs(referringNode);
    if (ListSequence.fromList(surroundingSyncs).isEmpty()) {
      return null;
    }
    for (SNode surroundingSync : ListSequence.fromList(surroundingSyncs)) {
      for (SNode surroundingSyncRessource : ListSequence.fromList(SLinkOperations.getTargets(surroundingSync, "ressources", true))) {
        SNode otherVariable = SyncRessource_Behavior.call_getVariable_1469333039370134366(surroundingSyncRessource);
        if (otherVariable != null && otherVariable == variable) {
          return surroundingSyncRessource;
        }
      }
    }
    return null;
  }



  public Pair<SNode, SNode> getVariableAndSyncRessource(SNode expr) {
    if (SNodeOperations.isInstanceOf(expr, "com.mbeddr.core.statements.structure.LocalVarRef") || SNodeOperations.isInstanceOf(expr, "com.mbeddr.core.modules.structure.ArgumentRef")) {
      SNode initVariable = BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), SNodeOperations.cast(SLinkOperations.getTarget(SNodeOperations.cast(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr"), "expression", true), "com.mbeddr.core.statements.structure.IVariableReference"), "virtual_getVariable_2486081302460156153", new Object[]{});
      SNode initVariableSyncRessource = getSyncForVariable(initVariable, expr);
      return new Pair(initVariable, initVariableSyncRessource);
    }
    if (SNodeOperations.isInstanceOf(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr") && (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr"), "expression", true), "com.mbeddr.core.statements.structure.LocalVarRef") || SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SNodeOperations.cast(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr"), "expression", true), "com.mbeddr.core.modules.structure.ArgumentRef"))) {
      SNode initVariable = BehaviorReflection.invokeVirtual((Class<SNode>) ((Class) Object.class), SNodeOperations.cast(SLinkOperations.getTarget(SNodeOperations.cast(expr, "com.mbeddr.core.pointers.structure.ReferenceExpr"), "expression", true), "com.mbeddr.core.statements.structure.IVariableReference"), "virtual_getVariable_2486081302460156153", new Object[]{});
      SNode initVariableSyncRessource = getSyncForVariable(initVariable, expr);
      return new Pair(initVariable, initVariableSyncRessource);
    }
    return null;
  }



  public void removeRecursiveSyncs(final Map<SNode, Map<SNode, Boolean>> nodeToReferencedNodes, Set<SNode> nodesWithUnknownStates) {
    SetSequence.fromSet(nodesWithUnknownStates).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        MapSequence.fromMap(nodeToReferencedNodes).removeKey(it);
      }
    });
    for (IMapping<SNode, Map<SNode, Boolean>> syncResourceAndRefedNodes : MapSequence.fromMap(nodeToReferencedNodes).where(new IWhereFilter<IMapping<SNode, Map<SNode, Boolean>>>() {
      public boolean accept(IMapping<SNode, Map<SNode, Boolean>> it) {
        return SNodeOperations.isInstanceOf(it.key(), "TasksAndSyncs.structure.SyncRessource");
      }
    })) {
      boolean isSynced = MapSequence.fromMap(syncResourceAndRefedNodes.value()).all(new IWhereFilter<IMapping<SNode, Boolean>>() {
        public boolean accept(IMapping<SNode, Boolean> it) {
          return it.value();
        }
      });
      if (isSynced) {
        SNodeOperations.deleteNode(syncResourceAndRefedNodes.key());
      }
    }
  }
}
