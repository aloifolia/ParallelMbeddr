\chapter{Design and Implementation}
In this chapter extension of mbeddr for parallel programming, called ParallelMbeddr, is introduced. To this end the new language features for C are explained each in terms of the design and the translation to plain mbeddr C code. Furthermore relevant implementation details are briefly depicted. A running example will help to illustrate the presented features.
\Bastian{TODO: explain running example}


\section{Tasks}
The basic parallelization element is a \textit{task}. It denotes a parallel unit of execution. Its named deliberately divergently from the prevalent parallelization terms(reference to basisc) in order to abstract from the concrete implementation which might change in the future.
\subsection{Design}
The syntax e of expressions in mbeddr is extended with

e ::= ... | |e|

When executed a task term yields a handle to a parallel unit of execution. This way the initialization of the task and the actual execution are decoupled and can happen . When it is run the embraced expression is executed and its value is returned. If the type of the expression is void no value will be returned. The type of a task reflects this return value.

t ::= ... | Task<t>

Due to implementation reasons the embraced return type of a task must be either void or a pointer to the type of the embraced expression:

e :- void
-----------------
|e| :- Task<void>

e :- t, t != void
-----------------
|e| :- Task<t*>


\subsection{Translation}
The pthreads library was chosen as a means to realize concurrency in the translation. It supports all necessary parallelization features and provides a more direct control of the generated code as opposed to frameworks like OpenMP (TODO: reference). Every task in ParalllelMbeddr is represented by a thread in pthreads. As the thread initialization function of pthreads takes a function pointer of type void* -> void* the computation of the translated task is represented by an according function:

void* parFun\_X(void* voidArgs) {...}

The X in the name symbolizes that for every task a unique adaptee of this function with the prefix parFun\_ and some unique suffix chosen by the framework is generated\footnote{In the following explanations X will always denote some arbitrary suffix. Keep in mind that these suffixes do not necessarily coincide for different kinds of components.}.

If a task contains any references to local variables or function arguments they need to be bound to capture the variable state at the time of the task initiliazation. Such state is represented by an argument struct:

struct Args\_X {
  t\_1 v\_1;
  ...
  t\_n v\_n;
}

where every v\_i denotes an equally named reference in the task expression of type t\_i.

The generated function parFun\_X is then given an instance of Args\_X which it uses to bind the references of the task expression to. The full function definition of a task e of type Task<t*> is, thus:

void* parFun\_X(void* voidArgs) {
  t* result = malloc(sizeof(t));
  Args\_X* args = (Args\_X*) voidArgs;
  *result = e';
  return result;
}

where e' is the expression obtained when every local variable reference and function argument reference r in e is substituted by a reference to an equally named and typed field in args:

r / args->r

If the embraced expression of a task does not contain any reference of this kind (e.g. only references to global variables) the args definition line is omitted as is clearly the---otherwise empty---struct Args\_X. In this case e' equals e.

The generated function of a Task<void> renounces the result-related statements:

void* parFun\_X(void* voidArgs) {
  t* result = malloc(sizeof(t));
  Args\_X* args = (Args\_X*) voidArgs;
  e';
}

Again, any argument related code is generated as needed.

The aforementioned handle that a task yields is represented by an instance of a corresponding struct that captures both the initilization state and the computation of the embraced expression\footnote{(void*) => (void*) fun is mbeddr syntax for the not easily edible function pointer void *(*fun) (void *) in standard C99}:

struct Task {
  void* args;
  (void*) => (void*) fun;
}

With these components in mind the actual translation of a task expression becomes an mbeddr block expression:

{
  Args\_X* args\_X = malloc(sizeof(Args\_X));
  args\_X->v\_1 = v\_1;
  ...
  args\_X->v\_n = v\_n;
}













\section{Tasks and Futures}
for all items mentioned in the language design and necessary intermediary MPS concepts:
\begin{itemize}
\item implemented structure
\item implemented typing rules
\item implemented generation rules
\end{itemize}
\section{Synchronization}
see above

