\chapter{Introduction}
Traditionally, the performance of processors is increased by raising their clock rates. Higher frequencies in turn entail even bigger power consumption heightenings. Various techniques are applied by manufacturers to compensate this effect, mainly the reduction of voltages. However, with the advent of the so-called power wall \cite{LocalizingGlobalsAndStatics}, the industry eventually had to and is still facing the problem of not being able to achieve this goal any more. One way to escape this dilemma that is of growing importance is the exchange of higher frequencies for more processor cores on a chip \cite{CPUScaling}. Instead of executing the instructions of programs continually faster, the multi-core approach is to execute multiple instructions in parallel. While multiple simultaneously running programs can thus be ran in parallel, with rising computational complexity, it is also desirable to distribute the execution of single programs across multiple cores. Yet, programs need to be accordingly designed in order to make use of the new architectures. Parallel programming needs to be applied. The art of this programming technique has proven to be substantially more difficult, since for programs, which run in parallel, program correctness is harder to achieve. This risen difficulty, in turn, influences the productivity and the costs of produced software \cite{ParallelProgrammerProductivity}.

As the trend towards multiprocessing has also reached the embedded domain \cite{MulticoreChallenges}\cite{LeveragingTheBenefits}, this domain is facing the same problems. One tool to ``boost the productivity'' \cite{mbeddr}f for this area is mbeddr. It offers new language-abstractions and integrated solutions for the development process. This is done by a compiler-based extension of the underlying programming language \textit{C}: language abstractions are repeatedly reduced into more basic language concepts until plain C code is obtained. In spite of mbeddr's various abstractions, it still misses native language support for parallel programming. While it is possible for the user to use according existing libraries, it is a laborious task to prepare mbeddr in this way. Even more important, the programmer is faced with the usual problems of such a library-based approach: the danger of data-races and the drawback of unnecessary computational overhead due to suboptimal countermeasures. Hand-based optimization of this overhead, in turn, introduces the potential for compromising the correctness of programs and is a tedious and costly process. It is therefore desirable to have native support for parallel programming in mbeddr. This thesis thus aims at providing the user with language concepts that enable him\footnote{In this text, for simplicity reasons, `he', `him' and `his' is used in a generic way and will always denote both sexes.} to write parallel code more easily while simultaneously mitigating the risks of incorrect execution. Additionally, this work will show how to reduce the design-based performance overhead, which the abstractions for data-race safety naturally entail. Due to the complexity of the underlying language C, the presented optimization techniques are prototypically implemented. 

The text has the following structure. Chapter \ref{background} will provide the reader with the necessary background to understand the reasoning of the following discussions. It gives short introductions to parallel programming, the character of the embedded domain and the language \textit{C} that is extended. The \ref{design_translation}rd chapter  will then introduce the concepts of the new language abstraction \textit{ParallelMbeddr}. To this end, the extension's design is presented, accompanied by the translation to the basic concepts that are provided by mbeddr. After this, chapter \ref{optimization} will show first techniques for compiler-based optimizations of the generated code of ParallelMbeddr. This is done in a declarative algorithmic way. Furthermore the text will depict the difficulties which arose in the prototypical implementation of the algorithms, and propose solution approaches therefor. The evaluation in chapter \ref{evaluation} will show the benefits and shortcomings of the design and implementation. Both the user-written and generated code for general parallelization examples will be investigated. Furthermore, the results of an optimization measurement will be shown and will reveal the performance potential for the compiler-based enhancement of C. The same chapter then gives a short comparison to relevant related work in the parallel-programming field.
Finally, chapter \ref{summary} will summarize the achievements and results of this work and briefly list promising fields of future research for ParallelMbeddr.
