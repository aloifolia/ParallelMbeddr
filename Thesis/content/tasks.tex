\section{Tasks}
The basic parallelization element is a \textit{task}. It denotes a parallel unit of execution and, as the name suggests, aims at task parallelism. As the implementation of the underlying parallelization technique might change in the future it is reasonable to abstract the terminology from it. The most basic task which always exists executes the code of the entry function of the program. A task can also be regarded as a closure of the expression that shall be run in parallel. The reader should distinguish this `execution template' from the actual running instance of a task. The latter will further on be addressed as a \textit{running task}.
\subsection{Design}
The syntax \texttt{e} of expressions in mbeddr is extended by

$e ::= ...|\;\mathit{|e|}$

When executed a task term yields a handle to a parallel unit of execution. This way the initialization of the task and the actual execution are decoupled and can happen independently. When a task is run the embraced expression is executed and its value is returned. If the type of the expression is \textit{void} no value will be returned. The type of a task reflects its return value:

$t ::= ... |\;\mathit{Task{<}t{>}}$

Due to implementation reasons (see \ref{futuresTranslation} for details) the embraced return type of a task must be either \textit{void} or a pointer to the type of the embraced expression:

\begin{align*}
\inference*[VoidTask]{e |- \mathit{void}}{|e| |- \mathit{Task{<}void{>}}} 
\qquad\qquad
\inference*[NonVoidTask]{e |- t & t \neq \mathit{void}}{|e| |- \mathit{Task{<}void{\text{*}}{>}}}
\end{align*}

When a task is not used anymore to produce running instances of itself it should be cleared in order to free the memory that it implicitly occupies on the heap:

$e ::= ...|\;e.\mathit{clear}$
\begin{align*}
\inference*[VoidTask]{|e| |- \mathit{Task{<}void{>}}}{\qquad\mathit{void}\qquad} 
\end{align*}

If a task is copied by the pass-by-value semantics of C the copied task will share the heap-managed data, i.e. the reference environment of its free variables, with the original task. Therefore a task needs to be cleared only once in order to avoid memory leaks. Keep in mind that a running instance of a task will not be affected by the clearance of its task template. 

\subsection{Translation}
\label{tasksTranslation}
The POSIX Threads standard and library (pthreads) was chosen as a means to realize concurrency in the translation. It supports all necessary parallelization features and provides a more direct control of the generated code when compared to frameworks like OpenMP\footnote{http://openmp.org/}. Every task in ParalllelMbeddr is represented by a thread as provided by the POSIX threads standard, a so-called \textit{pthread}\footnote{In the following sections `pthreads' will denote both the library and multiple threads as they are provided by the library. The context should always clarify which one is currently meant.}. As the thread initialization function of pthreads takes a function pointer of type \CODE{void* -> void*} the computation of the translated task is represented by an according function:
%\begin{ccode}
%void* parFun_X(void* voidArgs) {...}
%\end{ccode}
\begin{ccode}
void* parFun_X(void* voidArgs) {...}
\end{ccode}

The \CODE{X} in the name symbolizes that for every task a unique adaptee of this function with the prefix \CODE{parFun\_} and some unique suffix chosen by the framework is generated\footnote{In the following explanations \CODE{X} will always denote some arbitrary suffix. Keep in mind that these suffixes do not necessarily coincide for different kinds of components.}. As the function signature indicates a pthread and therefore a task to be run can be parameterized with values and can return a value which will be explained in the following paragraphs.

If a task contains any references to local variables or function arguments they need to be bound to capture the variable states at the time of the task initiliazation. Such state is represented by an `argument' struct:

\begin{ccode}
struct Args_X {
  t_1 v_1;
  ...
  t_n v_n;
}
\end{ccode}

where every \CODE{v\_i} represents an equally named reference in the task expression to a variable of type \CODE{t\_i}.

The generated function \CODE{parFun\_X} is then given an instance of \CODE{Args\_X} which it uses to bind the references of the task expression to. The full function definition of a task \CODE{e} of type \CODE{Task<t*>} is, thus:

\begin{ccode}
void* parFun_X(void* voidArgs) {
  t* result = malloc(sizeof(t));
  Args_X* args = (Args_X*) voidArgs;
  *result = e';
  return result;
}
\end{ccode}

where \CODE{e'} is the expression obtained when every local variable reference and function argument reference \CODE{r} in \CODE{e} is substituted by a reference to an equally named and typed field in args:

$r\;/\;args\text{-->}r$

If the embraced expression of a task does not contain any reference of this kind (e.g. only references to global variables) the \CODE{args} definition line is omitted as is clearly the---otherwise empty---declaration of \CODE{struct Args\_X}. In this case \CODE{e'} equals \CODE{e} except for other reductions of \CODE{e} that might occur in the translation process of mbeddr.

The generated function of a task of type \CODE{Task<void>} renounces the result-related statements:

\begin{ccode}
void* parFun_X(void* voidArgs) {
  t* result = malloc(sizeof(t));
  Args_X* args = (Args_X*) voidArgs;
  e';
}
\end{ccode}

Again, any argument-related code is generated as needed.

The aforementioned handle that a task yields is represented by an instance of a corresponding struct that captures both the initilization state and the computation of the embraced expression\footnote{\CODE{(void*) => (void*) fun} is mbeddr syntax for the not easily edible function pointer \CODE{void *(*fun) (void *)} in standard C99.}. The \textit{void} pointer of the arguments \CODE{voidArgs} does not keep their type information and with it their byte size. Therefore an additional field \CODE{argsSize} is needed in order to be able to create copies of the arguments later on (see \ref{futuresTranslation} for details).
\begin{ccode}
exported struct Task {
  void* args;
  (void*) => (void*) fun;
  size_t argsSize;
}
\end{ccode}

As opposed to the unique definitions of other elements that need to be defined for every occurence of a task (the ones with the \CODE{X} suffixes) \CODE{struct Task} is generic and is reused for every task. Generic declarations are kept in fixed seperately generated modules and are imported into the user-defined modules.
With these components in mind the actual translation of a task expression \CODE{|.|} that contains references \CODE{v\_i} to \CODE{v\_n} which need to be bound becomes an mbeddr block expression\footnote{A block expression contains a list of statements of which the mandatory yield statement returns the result value..}:

\begin{center}
\begin{minipage}{0.4\textwidth}
\begin{ccode}
{
  Args_X* args_X = malloc(sizeof(Args_X));
  args_X->v_1 = v_1;
  ...
  args_X->v_n = v_n;
  yield (Task){ args_X, parFun_X, sizeof(Args_X) };
}
\end{ccode}
\end{minipage}
\quad$\Longrightarrow$\qquad
\begin{minipage}{0.4\textwidth}
\begin{ccode}
taskInit(v_1, ..., v_n)
\end{ccode}
with function declaration
\begin{ccode}
inline Args_X taskInit(t_1 v_1, ..., t_n v_n) {
  Args_X* args_X = malloc(sizeof(Args_X));
  args_X - >v_1 = v_1;
  ...
  args_X->v_n = v_n;
  return (Task){ args_X, parFun_X, sizeof(Args_X) };
}
\end{ccode}
\end{minipage}
\end{center}

The expression of the \CODE{yield} statement is a compound literal which on evaluation creates an instance of the aforementioned \CODE{struct Task}. The block expression is then further reduced by mbeddr to a call of a newly generated inline function\footnote{Whereas in C for every struct type \CODE{T} a typedef has to be defined in order to reference this type directly with \CODE{T} instead of \CODE{struct T} in mbeddr this definition is done implicitly.}.

Without any references to bind a task is just reduced to the compound literal:

\begin{ccode}
(Task_X){ null, parFun_X, 0 }
\end{ccode}

By above definition of \CODE{parFun\_X} it becomes clear that the arguments of a task---its environment---are stored on the heap before execution. This approach was chosen mainly in order to simplify the generation of the resulting code. In exchange both the result and the arguments of a task have to be deleted by the programmer by hand. Since for reasons to be explained later the result is returned via a pointer onto the heap, as well, it now becomes obvious that the return type of a task must either be a void type or a pointer type as was mentioned in the design section. Concerning task arguments one advantage of this implementation is that a task may be passed by value, e.g. when using a builder function to create tasks, without the possible need to copy multiple arguments. Instead just the pointer to the heap-managed data is copied. As will be shown in the (FUTURE WORK) chapter a stack-based implementation of task (I/O) is conceivable. 

The clearance of a task \CODE{e.clear} in the generated code is a call of the \CODE{free} function of C parameterized with the arguments of the translated task \CODE{e'}:
\begin{ccode}
free(e'.args)
\end{ccode}

\subsection{Example code}
\label{taskExample}
The running example is about the calculation of $\pi$, based on the definition given in the concurrent-pi example for go\footnote{https://github.com/foamdino/learning-go/blob/master/concurrent-pi/concurrent-pi.go}. $\pi$ is approximated by the summation of a certain number \textit{n} of terms where \textit{n} determines the deviation of the result from the actual value of $\pi$: 
${\pi}_{\mathrm{approx}} = \sum\limits_{i=0}^{n}4*{-1^i \over 2i+1}$. 

In the first scenario the amount of work is distributed under a certain number of tasks each of which calculates the contribution of summands for a range of indices \textit{i}. The calculation of such a partial sum for a range $[\mathrm{start}, \mathrm{end}[$ of indices is done by the functions:
\begin{ccode}
long double calcPiRange(uint32 start, uint32 end) { 
  long double partialSum = 0; 
  for (uint32 i = start; i < end; ++i) { 
    partialSum += calcPiItem(i); 
  }
  return partialSum; 
}
 
long double calcPiItem(uint32 index) { 
  return 4.0 * (pow (-1.0, index) / (2.0 * index + 1.0)); 
}
\end{ccode}
The work can be distributed among, e.g. 4 tasks where each task calculates a partial sum for an equally long range which is given by:
\begin{ccode}
#constant RANGESIZE = 300000000;
#constant RANGECOUNT = 4; 
#constant THRESHOLD = RANGESIZE * RANGECOUNT;
\end{ccode}
These values are then used to initialize an array of tasks:
\begin{ccode}
int32 main(int32 argc, string[] argv) {
...
  Task<long double*>[RANGECOUNT] calculators;
  for (i ++ in [0..RANGECOUNT[) { 
    uint32 start = i * RANGESIZE; 
    uint32 end = start + RANGESIZE; 
    calculators[i] = |calcPiRange(start, end)|; 
  }
...
}
\end{ccode}
The final reduction of the calculated values will be shown after the presentation of futures in section \ref{futuresExample}. The code is translated\footnote{For legibility reasons the code shown in the following listing and any other mbeddr code is a simplified version of the intermediate code that mbeddr actually generates. The performed changes are restricted to renamings and other minor adjustments.} to the building blocks that were introduced in \ref{tasksTranslation}:
\begin{ccode}

int32 main(int32 argc, string[] argv) {
...
  Task[RANGECOUNT] calculators;
  for (int8 __i = 0; __i < RANGECOUNT; __i++) { 
    uint32 start = __i * RANGESIZE; 
    uint32 end = start + RANGESIZE; 
    calculators[__i] = taskInit_0(start, end); 
  }
...
}

struct Args_0 { 
  uint32 start; 
  uint32 end; 
};

inline Task taskInit_0(uint32 start, uint32 end) { 
  Args_0* args_0 = malloc(sizeof(Args_0)); 
  Args_0->start = start; 
  Args_0->end = end; 
  return (Task){ args_0 , :parFun_0 , sizeof (Args_0)}; 
}

void* parFun_0(void* voidArgs) { 
  long double* result = malloc(sizeof(long double)); 
  Args_0* args = ((Args_0*) voidArgs); 
  *result = calcPiRange((args)->start, (args)->end); 
  free(voidArgs); 
  return result; 
}
\end{ccode}
The type of \CODE{calculators} is translated into an array type of the generic \CODE{Task} struct type such that the type specification \CODE{long double*} which is not needed in the translated code gets lost in this process. The task expression \CODE{|calcPiRange(start, end)|} is translated into a function call of the generated inline function \CODE{taskInit\_0}. This function stores the values of the referenced local variables \CODE{start} and \CODE{end} in a structure which will later be used as the input for the parallel executed function \CODE{parFun\_0}. This function, the wrapped arguments and their size are stored in a generic \CODE{Task} structure instance which is the handle that will later be used to initiate the task. \CODE{parFun\_0} takes its arguments generically (as is required by the POSIX threads standard) and also returns its result generically via the heap. As the arguments reside on the heap and are uniquely allocated for this function they must be freed before \CODE{parFun\_0} returns. The calculation of the result is straightforwardly given by the execution of the expression of the original task sub expression \CODE{calcPiRange(start, end)} except that the two variable references are substituted by references to the according fields in the argument struct instance \CODE{voidArgs} which is cast to the appropriate type \CODE{Args\_0}.
