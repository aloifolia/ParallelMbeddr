\section{Futures}
Whenever a task \CODE{t} is run a \textit{future} is generated. Futures in ParallelMbeddr are based on Halstead's definition of a future\cite{Halstead_Multilisp}. A future is a handle to a running task that can be used to retrieve the result of this task from within some other task \CODE{u}. As soon as this happens the formerly in parallel running task \CODE{u} joins \CODE{t} which means that it waits for \CODE{t} to finish execution in order to get its result value. The asynchronous execution is, thus, synchronized.

\subsection{Design}
The syntax \texttt{e} of expressions in mbeddr is extended by\footnote{If the expression e has a pointer type the dots (\CODE{.}) are replaced by arrows (\CODE{->}).}:

$ e ::= ...|\;e.\mathit{run}\;|\;e.\mathit{result}\;|\;e.\mathit{join} $

Like with tasks the type of a future is parameterized by its return type:

$ t ::= ...|\;\mathit{Future{<}t{>}}$

\CODE{e.run} denotes the launch of task \CODE{e} whereas \CODE{e.result} joins a running task that is represented by a future handle \CODE{e}, i.e. halts the execution of the calling task until \CODE{e}'s execution is finished, and returns its result. The last expression \CODE{e.join} can be used to join tasks that return nothing. These properties are reflected in the typing rules:

\begin{center}
\begin{align*}
\inference*[Future]{e |- \mathit{Task{<}t{>}}}{e.\mathit{run} |- \mathit{Future{<}t{>}}}
\qquad\qquad
\inference*[FutureResult]{e |- \mathit{Task{<}t\text{*}{>}}}{e.\mathit{result} |- t\text{*}}
\qquad\qquad
\inference*[FutureJoin]{e |- \mathit{Task{<}void{>}}}{e.\mathit{join} |- \mathit{void}}
\end{align*}
\end{center}

As was already depicted in the previous section  
\CODE{result} returns a pointer to a heap-managed value. Hence the programmer has to take care of freeing the value eventually.

\subsection{Translation}
\label{futuresTranslation}
A future type \CODE{Future<t*>} is translated to a generic \CODE{struct} that contains a handle to the thread, a storage for the result value---which is dropped for futures of type \CODE{Future<void>}---and a flag that indicates whether the thread is already finished:
\begin{ccode}
exported struct Future { 
  pthread_t pth; 
  boolean finished; 
  void* result; 
};
\end{ccode}

For every task and future expression shown above a generic function reflects the semantics in the translation. The \CODE{run} of a task involves taking a task, creating a pthread with the task's function pointer and arguments and generating a future with the initialized thread handle\footnote{Obviously the thread handle is copied into the \CODE{Future}. This is safe as can be seen when looking at the POSIX function \CODE{pthread\_t pthread\_self(void)} which also returns a copy of a thread handle. This useful property is worth mentioning since it does not hold for all POSIX related data structures as is explained in footnote \ref{mutexCopies}.}:
\begin{ccode}
Future runTaskAndGetFuture(Task task) { 
  pthread_t pth;
  if ( task.argsSize == 0 ) {
      pthread_create(&pth, 0, task.fun, 0);
  } else {
    void* args = malloc(task.argsSize);
    memcpy(args, task.args, task.argsSize);
    pthread_create(&pth, 0, task.fun, args);
  }
  return ( Future ){ .pth = pth }; 
}
\end{ccode}
The code shows that the arguments to be provided to the thread are copied onto a new location on the heap although they already reside on the heap as was shown in section \ref{tasksTranslation}. It is necessary to do so in order to avoid dangling pointers. These could arise when a task is cleared so that its arguments get deleted while one ore more running instances (pthreads) of this task are not finished, yet. Furthermore generally every thread needs its own copy of the data in case it modifies it. A corresponding function to the previous function, called \CODE{runTaskAndGetVoidFuture}, is generated for futures that return nothing. The signature of \CODE{pthread\_create} indicates how the result of a threaded function can be received. Like was already previously suggested it expects a function pointer of type \CODE{void* -> void*} which is the reason why the function generated for a task is equally typed. The result is, thus, a generic \CODE{void} pointer. This implies that the threaded function could generally return the address of a stack-managed value, i.e. a local variable. Since the existance of the value after thread termination could not be guaranteed a dangling pointer\cite{UnderstandingAndUsingCPointers} could emerge, which resembles the problem for thread arguments. The only safe alternative that fits the task-future structure well is to allocate memory on the heap and return the address of this memory (see section \ref{tasksTranslation}). The translation of the result retrieval is a call the function:

\begin{ccode}
void* getFutureResult(Future* future) { 
  if (!future->finished) { 
    pthread_join (future->pth, &(future->result)); 
    future->finished = true; 
  } 
  return future->result; 
} 
\end{ccode}
First the future is used to join the according thread which blocks the execution until the thread is finished. Additionally the result is copied into the designated slot of the future struct instance. The result is at last returned. In POSIX a thread can only be joined once; every subsequent call causes a runtime error. In order to allow the user to request the result multiple times nevertheless the \CODE{finished} flag is used to decide whether a join should happen. The same basic structure can be found in the translation of the \CODE{join} function for a future of type \CODE{Future<void>}. The main difference is the missing result-related code:
\begin{ccode}
void joinVoidFuture(VoidFuture* future) { 
  if (!future->finished) { 
    pthread_join (future->pth, null); 
    future->finished = true; 
  }
}
\end{ccode}
Both aforementioned generated functions take their future parameters by address. This is necessary to make the setting of the future data work. If futures struct instances would be passed to these functions as is due to C's pass-by-value semantics only copies of the provided future arguments would be filled with data. The result of a task would never arrive in the original future struct instance. Furthermore subsequent calls to these functions would always work with false \CODE{finished} flags and ultimately trigger runtime errors. The necessity for future pointers in turn does not assort well with chained future expressions like:

\begin{ccode}
Task<int32*> task = |(int32)23|;
int32* result23 = task.run.result;
\end{ccode}

In this sample code the result of the future is requested without being stored beforehand and accessed via address. Hence the code conflicts with the previously given definition of the translation of \CODE{result}. A first caveat would be to change the line to:

\begin{ccode}
int32* result23 = (&(task.run))->result;
\end{ccode}

This on the other hand is not allowed because \CODE{task.run} is no lvalue\cite[pp.~147-148]{CPrimerPlus} which disallows the utilization of the address operator on this expression. Instead in order to allow for chainings like \CODE{task.run.result} two wrapper functions, one for each \CODE{join} and \CODE{result}, are provided. These functions each take a future by argument, thus binding it to an adressable location, and call above corresponding functions in turn:
\begin{ccode}
void* saveFutureAndGetResult(Future future) { 
  return getFutureResult(&future); 
}

void saveAndJoinVoidFuture(VoidFuture future) { 
  joinVoidFuture(&future); 
}
\end{ccode}

By making use of the presented functions the reductions of \CODE{e.run}, \CODE{e.join} and \CODE{e.result} (where \CODE{e'} is the reduced value of \CODE{e}) straightforwardly become function calls thereof:

\begin{minipage}{0.5\textwidth}
\begin{ccode}
runTaskAndGetFuture(e')
\end{ccode}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{ccode}
runTaskAndGetVoidFuture(e')
\end{ccode}
\end{minipage}

\begin{minipage}{0.5\textwidth}
\begin{ccode}
((t)getFutureResult(&e'))
\end{ccode}
\end{minipage}
\begin{minipage}{0.5\textwidth}
\begin{ccode}
joinFuture(&e')
\end{ccode}
\end{minipage}

The type cast of the result returned by \CODE{getFutureResult(\&e')} is necessary since it returns a generic pointer \CODE{void*} which may not be compatible with the receiver of the value. In consequence the result is cast to the result type of the future for which \CODE{e.result} was type checked.

\subsection{Example code}
\label{futuresExample}
The running example concerning the $\pi$ approximation from section \ref{taskExample} can now be extended with the result-related code. The tasks that were previously declared are used to initiate a running task instance of each such `template':
\begin{ccode}
int32 main(int32 argc, string[] argv) {
  Task<long double*>[RANGECOUNT] calculators; 
  Future<long double*>[RANGECOUNT] partialResults;
  
  ... // task declarations
  
  for (i ++ in [0..RANGECOUNT[) { 
    partialResults[i] = calculators[i].run; 
    calculators[i].clear; 
  }
   
  for (i ++ in [0..RANGECOUNT[) { 
    result += *(partialResults[i].result); 
    free(partialResults[i].result); 
  }
}
\end{ccode}
For every task that is run a future of the same type is created. After the initialization the tasks (i.e. the task templates, not the running instances thereof) are cleared in order to avoid memory leaks. The programmer is free to choose whether he is willing to do so. In case only a very limited amount of memory will be used by the tasks the clearance might not be deemed necessary. In the second loop the futures of all running tasks are used to retrieve and accumulate all partial $\pi$ results. In the end their memory is freed since they are located on the heap. Again, the freeing is up to the programmer and in the end of the program might not be even useful.
The translation of the new code becomes:
\begin{ccode}
int32 main(int32 argc, string[] argv) {
  Task[RANGECOUNT] calculators; 
  Future[RANGECOUNT] partialResults;
  
  ... // task declarations
  
  for (int8 __i = 0; __i < RANGECOUNT; __i++) { 
    partialResults[__i] = runTaskAndGetFuture(calculators[__i]); 
    free (calculators[__i].args); 
  }
   
  for (int8 __i = 0; __i < RANGECOUNT; __i++) { 
    result += *(((long double*) getFutureResult(&partialResults[__i]))); 
    free((long double*) getFutureResult(&partialResults[__i])); 
  } for
  
\end{ccode}
As the code shows the future type becomes the type of the according generic \CODE{Future} struct. Like the translation of the task type it loses the type parameterization \CODE{long double*} which is not necessary any more. The task running expression \CODE{calculators[i].run} and result retrieval expression \CODE{partialResults[i].result} are translated to calls of the newly generated generic functions \CODE{runTaskAndGetFuture()}, respectively \CODE{runTaskAndGetFuture()}. Their definitions can be seen in the previous section \ref{tasksTranslation}. Due to its genericity \CODE{runTaskAndGetFuture()} returns a result of type \CODE{void*} which means that its result must be cast by the compiler to an appropriate pointer type which in this case is \CODE{long double*} like in the original task and future definitions. Finally, the task clearance is simply reduced to a call of C's free function parameterized with the pointer to an argument struct instance that the task holds.